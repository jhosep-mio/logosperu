"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/viewerjs";
exports.ids = ["vendor-chunks/viewerjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/viewerjs/dist/viewer.css":
/*!***********************************************!*\
  !*** ./node_modules/viewerjs/dist/viewer.css ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"8cc334ada7b8\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlld2VyanMvZGlzdC92aWV3ZXIuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbG9nb3NwZXJ1X25leHRqcy8uL25vZGVfbW9kdWxlcy92aWV3ZXJqcy9kaXN0L3ZpZXdlci5jc3M/NTMxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjhjYzMzNGFkYTdiOFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/viewerjs/dist/viewer.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/viewerjs/dist/viewer.common.js":
/*!*****************************************************!*\
  !*** ./node_modules/viewerjs/dist/viewer.common.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/*!\n * Viewer.js v1.11.6\n * https://fengyuanchen.github.io/viewerjs\n *\n * Copyright 2015-present Chen Fengyuan\n * Released under the MIT license\n *\n * Date: 2023-09-17T03:16:38.052Z\n */\n\n\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nvar DEFAULTS = {\n  /**\n   * Enable a modal backdrop, specify `static` for a backdrop\n   * which doesn't close the modal on click.\n   * @type {boolean}\n   */\n  backdrop: true,\n  /**\n   * Show the button on the top-right of the viewer.\n   * @type {boolean}\n   */\n  button: true,\n  /**\n   * Show the navbar.\n   * @type {boolean | number}\n   */\n  navbar: true,\n  /**\n   * Specify the visibility and the content of the title.\n   * @type {boolean | number | Function | Array}\n   */\n  title: true,\n  /**\n   * Show the toolbar.\n   * @type {boolean | number | Object}\n   */\n  toolbar: true,\n  /**\n   * Custom class name(s) to add to the viewer's root element.\n   * @type {string}\n   */\n  className: '',\n  /**\n   * Define where to put the viewer in modal mode.\n   * @type {string | Element}\n   */\n  container: 'body',\n  /**\n   * Filter the images for viewing. Return true if the image is viewable.\n   * @type {Function}\n   */\n  filter: null,\n  /**\n   * Enable to request fullscreen when play.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/FullscreenOptions}\n   * @type {boolean|FullscreenOptions}\n   */\n  fullscreen: true,\n  /**\n   * Define the extra attributes to inherit from the original image.\n   * @type {Array}\n   */\n  inheritedAttributes: ['crossOrigin', 'decoding', 'isMap', 'loading', 'referrerPolicy', 'sizes', 'srcset', 'useMap'],\n  /**\n   * Define the initial coverage of the viewing image.\n   * @type {number}\n   */\n  initialCoverage: 0.9,\n  /**\n   * Define the initial index of the image for viewing.\n   * @type {number}\n   */\n  initialViewIndex: 0,\n  /**\n   * Enable inline mode.\n   * @type {boolean}\n   */\n  inline: false,\n  /**\n   * The amount of time to delay between automatically cycling an image when playing.\n   * @type {number}\n   */\n  interval: 5000,\n  /**\n   * Enable keyboard support.\n   * @type {boolean}\n   */\n  keyboard: true,\n  /**\n   * Focus the viewer when initialized.\n   * @type {boolean}\n   */\n  focus: true,\n  /**\n   * Indicate if show a loading spinner when load image or not.\n   * @type {boolean}\n   */\n  loading: true,\n  /**\n   * Indicate if enable loop viewing or not.\n   * @type {boolean}\n   */\n  loop: true,\n  /**\n   * Min width of the viewer in inline mode.\n   * @type {number}\n   */\n  minWidth: 200,\n  /**\n   * Min height of the viewer in inline mode.\n   * @type {number}\n   */\n  minHeight: 100,\n  /**\n   * Enable to move the image.\n   * @type {boolean}\n   */\n  movable: true,\n  /**\n   * Enable to rotate the image.\n   * @type {boolean}\n   */\n  rotatable: true,\n  /**\n   * Enable to scale the image.\n   * @type {boolean}\n   */\n  scalable: true,\n  /**\n   * Enable to zoom the image.\n   * @type {boolean}\n   */\n  zoomable: true,\n  /**\n   * Enable to zoom the current image by dragging on the touch screen.\n   * @type {boolean}\n   */\n  zoomOnTouch: true,\n  /**\n   * Enable to zoom the image by wheeling mouse.\n   * @type {boolean}\n   */\n  zoomOnWheel: true,\n  /**\n   * Enable to slide to the next or previous image by swiping on the touch screen.\n   * @type {boolean}\n   */\n  slideOnTouch: true,\n  /**\n   * Indicate if toggle the image size between its natural size\n   * and initial size when double click on the image or not.\n   * @type {boolean}\n   */\n  toggleOnDblclick: true,\n  /**\n   * Show the tooltip with image ratio (percentage) when zoom in or zoom out.\n   * @type {boolean}\n   */\n  tooltip: true,\n  /**\n   * Enable CSS3 Transition for some special elements.\n   * @type {boolean}\n   */\n  transition: true,\n  /**\n   * Define the CSS `z-index` value of viewer in modal mode.\n   * @type {number}\n   */\n  zIndex: 2015,\n  /**\n   * Define the CSS `z-index` value of viewer in inline mode.\n   * @type {number}\n   */\n  zIndexInline: 0,\n  /**\n   * Define the ratio when zoom the image by wheeling mouse.\n   * @type {number}\n   */\n  zoomRatio: 0.1,\n  /**\n   * Define the min ratio of the image when zoom out.\n   * @type {number}\n   */\n  minZoomRatio: 0.01,\n  /**\n   * Define the max ratio of the image when zoom in.\n   * @type {number}\n   */\n  maxZoomRatio: 100,\n  /**\n   * Define where to get the original image URL for viewing.\n   * @type {string | Function}\n   */\n  url: 'src',\n  /**\n   * Event shortcuts.\n   * @type {Function}\n   */\n  ready: null,\n  show: null,\n  shown: null,\n  hide: null,\n  hidden: null,\n  view: null,\n  viewed: null,\n  move: null,\n  moved: null,\n  rotate: null,\n  rotated: null,\n  scale: null,\n  scaled: null,\n  zoom: null,\n  zoomed: null,\n  play: null,\n  stop: null\n};\n\nvar TEMPLATE = '<div class=\"viewer-container\" tabindex=\"-1\" touch-action=\"none\">' + '<div class=\"viewer-canvas\"></div>' + '<div class=\"viewer-footer\">' + '<div class=\"viewer-title\"></div>' + '<div class=\"viewer-toolbar\"></div>' + '<div class=\"viewer-navbar\">' + '<ul class=\"viewer-list\" role=\"navigation\"></ul>' + '</div>' + '</div>' + '<div class=\"viewer-tooltip\" role=\"alert\" aria-hidden=\"true\"></div>' + '<div class=\"viewer-button\" data-viewer-action=\"mix\" role=\"button\"></div>' + '<div class=\"viewer-player\"></div>' + '</div>';\n\nvar IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined';\nvar WINDOW = IS_BROWSER ? window : {};\nvar IS_TOUCH_DEVICE = IS_BROWSER && WINDOW.document.documentElement ? 'ontouchstart' in WINDOW.document.documentElement : false;\nvar HAS_POINTER_EVENT = IS_BROWSER ? 'PointerEvent' in WINDOW : false;\nvar NAMESPACE = 'viewer';\n\n// Actions\nvar ACTION_MOVE = 'move';\nvar ACTION_SWITCH = 'switch';\nvar ACTION_ZOOM = 'zoom';\n\n// Classes\nvar CLASS_ACTIVE = \"\".concat(NAMESPACE, \"-active\");\nvar CLASS_CLOSE = \"\".concat(NAMESPACE, \"-close\");\nvar CLASS_FADE = \"\".concat(NAMESPACE, \"-fade\");\nvar CLASS_FIXED = \"\".concat(NAMESPACE, \"-fixed\");\nvar CLASS_FULLSCREEN = \"\".concat(NAMESPACE, \"-fullscreen\");\nvar CLASS_FULLSCREEN_EXIT = \"\".concat(NAMESPACE, \"-fullscreen-exit\");\nvar CLASS_HIDE = \"\".concat(NAMESPACE, \"-hide\");\nvar CLASS_HIDE_MD_DOWN = \"\".concat(NAMESPACE, \"-hide-md-down\");\nvar CLASS_HIDE_SM_DOWN = \"\".concat(NAMESPACE, \"-hide-sm-down\");\nvar CLASS_HIDE_XS_DOWN = \"\".concat(NAMESPACE, \"-hide-xs-down\");\nvar CLASS_IN = \"\".concat(NAMESPACE, \"-in\");\nvar CLASS_INVISIBLE = \"\".concat(NAMESPACE, \"-invisible\");\nvar CLASS_LOADING = \"\".concat(NAMESPACE, \"-loading\");\nvar CLASS_MOVE = \"\".concat(NAMESPACE, \"-move\");\nvar CLASS_OPEN = \"\".concat(NAMESPACE, \"-open\");\nvar CLASS_SHOW = \"\".concat(NAMESPACE, \"-show\");\nvar CLASS_TRANSITION = \"\".concat(NAMESPACE, \"-transition\");\n\n// Native events\nvar EVENT_CLICK = 'click';\nvar EVENT_DBLCLICK = 'dblclick';\nvar EVENT_DRAG_START = 'dragstart';\nvar EVENT_FOCUSIN = 'focusin';\nvar EVENT_KEY_DOWN = 'keydown';\nvar EVENT_LOAD = 'load';\nvar EVENT_ERROR = 'error';\nvar EVENT_TOUCH_END = IS_TOUCH_DEVICE ? 'touchend touchcancel' : 'mouseup';\nvar EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? 'touchmove' : 'mousemove';\nvar EVENT_TOUCH_START = IS_TOUCH_DEVICE ? 'touchstart' : 'mousedown';\nvar EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? 'pointerdown' : EVENT_TOUCH_START;\nvar EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? 'pointermove' : EVENT_TOUCH_MOVE;\nvar EVENT_POINTER_UP = HAS_POINTER_EVENT ? 'pointerup pointercancel' : EVENT_TOUCH_END;\nvar EVENT_RESIZE = 'resize';\nvar EVENT_TRANSITION_END = 'transitionend';\nvar EVENT_WHEEL = 'wheel';\n\n// Custom events\nvar EVENT_READY = 'ready';\nvar EVENT_SHOW = 'show';\nvar EVENT_SHOWN = 'shown';\nvar EVENT_HIDE = 'hide';\nvar EVENT_HIDDEN = 'hidden';\nvar EVENT_VIEW = 'view';\nvar EVENT_VIEWED = 'viewed';\nvar EVENT_MOVE = 'move';\nvar EVENT_MOVED = 'moved';\nvar EVENT_ROTATE = 'rotate';\nvar EVENT_ROTATED = 'rotated';\nvar EVENT_SCALE = 'scale';\nvar EVENT_SCALED = 'scaled';\nvar EVENT_ZOOM = 'zoom';\nvar EVENT_ZOOMED = 'zoomed';\nvar EVENT_PLAY = 'play';\nvar EVENT_STOP = 'stop';\n\n// Data keys\nvar DATA_ACTION = \"\".concat(NAMESPACE, \"Action\");\n\n// RegExps\nvar REGEXP_SPACES = /\\s\\s*/;\n\n// Misc\nvar BUTTONS = ['zoom-in', 'zoom-out', 'one-to-one', 'reset', 'prev', 'play', 'next', 'rotate-left', 'rotate-right', 'flip-horizontal', 'flip-vertical'];\n\n/**\n * Check if the given value is a string.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is a string, else `false`.\n */\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\n/**\n * Check if the given value is not a number.\n */\nvar isNaN = Number.isNaN || WINDOW.isNaN;\n\n/**\n * Check if the given value is a number.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is a number, else `false`.\n */\nfunction isNumber(value) {\n  return typeof value === 'number' && !isNaN(value);\n}\n\n/**\n * Check if the given value is undefined.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is undefined, else `false`.\n */\nfunction isUndefined(value) {\n  return typeof value === 'undefined';\n}\n\n/**\n * Check if the given value is an object.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is an object, else `false`.\n */\nfunction isObject(value) {\n  return _typeof(value) === 'object' && value !== null;\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Check if the given value is a plain object.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is a plain object, else `false`.\n */\nfunction isPlainObject(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  try {\n    var _constructor = value.constructor;\n    var prototype = _constructor.prototype;\n    return _constructor && prototype && hasOwnProperty.call(prototype, 'isPrototypeOf');\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Check if the given value is a function.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is a function, else `false`.\n */\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n\n/**\n * Iterate the given data.\n * @param {*} data - The data to iterate.\n * @param {Function} callback - The process function for each element.\n * @returns {*} The original data.\n */\nfunction forEach(data, callback) {\n  if (data && isFunction(callback)) {\n    if (Array.isArray(data) || isNumber(data.length) /* array-like */) {\n      var length = data.length;\n      var i;\n      for (i = 0; i < length; i += 1) {\n        if (callback.call(data, data[i], i, data) === false) {\n          break;\n        }\n      }\n    } else if (isObject(data)) {\n      Object.keys(data).forEach(function (key) {\n        callback.call(data, data[key], key, data);\n      });\n    }\n  }\n  return data;\n}\n\n/**\n * Extend the given object.\n * @param {*} obj - The object to be extended.\n * @param {*} args - The rest objects which will be merged to the first object.\n * @returns {Object} The extended object.\n */\nvar assign = Object.assign || function assign(obj) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  if (isObject(obj) && args.length > 0) {\n    args.forEach(function (arg) {\n      if (isObject(arg)) {\n        Object.keys(arg).forEach(function (key) {\n          obj[key] = arg[key];\n        });\n      }\n    });\n  }\n  return obj;\n};\nvar REGEXP_SUFFIX = /^(?:width|height|left|top|marginLeft|marginTop)$/;\n\n/**\n * Apply styles to the given element.\n * @param {Element} element - The target element.\n * @param {Object} styles - The styles for applying.\n */\nfunction setStyle(element, styles) {\n  var style = element.style;\n  forEach(styles, function (value, property) {\n    if (REGEXP_SUFFIX.test(property) && isNumber(value)) {\n      value += 'px';\n    }\n    style[property] = value;\n  });\n}\n\n/**\n * Escape a string for using in HTML.\n * @param {String} value - The string to escape.\n * @returns {String} Returns the escaped string.\n */\nfunction escapeHTMLEntities(value) {\n  return isString(value) ? value.replace(/&(?!amp;|quot;|#39;|lt;|gt;)/g, '&amp;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;') : value;\n}\n\n/**\n * Check if the given element has a special class.\n * @param {Element} element - The element to check.\n * @param {string} value - The class to search.\n * @returns {boolean} Returns `true` if the special class was found.\n */\nfunction hasClass(element, value) {\n  if (!element || !value) {\n    return false;\n  }\n  return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;\n}\n\n/**\n * Add classes to the given element.\n * @param {Element} element - The target element.\n * @param {string} value - The classes to be added.\n */\nfunction addClass(element, value) {\n  if (!element || !value) {\n    return;\n  }\n  if (isNumber(element.length)) {\n    forEach(element, function (elem) {\n      addClass(elem, value);\n    });\n    return;\n  }\n  if (element.classList) {\n    element.classList.add(value);\n    return;\n  }\n  var className = element.className.trim();\n  if (!className) {\n    element.className = value;\n  } else if (className.indexOf(value) < 0) {\n    element.className = \"\".concat(className, \" \").concat(value);\n  }\n}\n\n/**\n * Remove classes from the given element.\n * @param {Element} element - The target element.\n * @param {string} value - The classes to be removed.\n */\nfunction removeClass(element, value) {\n  if (!element || !value) {\n    return;\n  }\n  if (isNumber(element.length)) {\n    forEach(element, function (elem) {\n      removeClass(elem, value);\n    });\n    return;\n  }\n  if (element.classList) {\n    element.classList.remove(value);\n    return;\n  }\n  if (element.className.indexOf(value) >= 0) {\n    element.className = element.className.replace(value, '');\n  }\n}\n\n/**\n * Add or remove classes from the given element.\n * @param {Element} element - The target element.\n * @param {string} value - The classes to be toggled.\n * @param {boolean} added - Add only.\n */\nfunction toggleClass(element, value, added) {\n  if (!value) {\n    return;\n  }\n  if (isNumber(element.length)) {\n    forEach(element, function (elem) {\n      toggleClass(elem, value, added);\n    });\n    return;\n  }\n\n  // IE10-11 doesn't support the second parameter of `classList.toggle`\n  if (added) {\n    addClass(element, value);\n  } else {\n    removeClass(element, value);\n  }\n}\nvar REGEXP_HYPHENATE = /([a-z\\d])([A-Z])/g;\n\n/**\n * Transform the given string from camelCase to kebab-case\n * @param {string} value - The value to transform.\n * @returns {string} The transformed value.\n */\nfunction hyphenate(value) {\n  return value.replace(REGEXP_HYPHENATE, '$1-$2').toLowerCase();\n}\n\n/**\n * Get data from the given element.\n * @param {Element} element - The target element.\n * @param {string} name - The data key to get.\n * @returns {string} The data value.\n */\nfunction getData(element, name) {\n  if (isObject(element[name])) {\n    return element[name];\n  }\n  if (element.dataset) {\n    return element.dataset[name];\n  }\n  return element.getAttribute(\"data-\".concat(hyphenate(name)));\n}\n\n/**\n * Set data to the given element.\n * @param {Element} element - The target element.\n * @param {string} name - The data key to set.\n * @param {string} data - The data value.\n */\nfunction setData(element, name, data) {\n  if (isObject(data)) {\n    element[name] = data;\n  } else if (element.dataset) {\n    element.dataset[name] = data;\n  } else {\n    element.setAttribute(\"data-\".concat(hyphenate(name)), data);\n  }\n}\nvar onceSupported = function () {\n  var supported = false;\n  if (IS_BROWSER) {\n    var once = false;\n    var listener = function listener() {};\n    var options = Object.defineProperty({}, 'once', {\n      get: function get() {\n        supported = true;\n        return once;\n      },\n      /**\n       * This setter can fix a `TypeError` in strict mode\n       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}\n       * @param {boolean} value - The value to set\n       */\n      set: function set(value) {\n        once = value;\n      }\n    });\n    WINDOW.addEventListener('test', listener, options);\n    WINDOW.removeEventListener('test', listener, options);\n  }\n  return supported;\n}();\n\n/**\n * Remove event listener from the target element.\n * @param {Element} element - The event target.\n * @param {string} type - The event type(s).\n * @param {Function} listener - The event listener.\n * @param {Object} options - The event options.\n */\nfunction removeListener(element, type, listener) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var handler = listener;\n  type.trim().split(REGEXP_SPACES).forEach(function (event) {\n    if (!onceSupported) {\n      var listeners = element.listeners;\n      if (listeners && listeners[event] && listeners[event][listener]) {\n        handler = listeners[event][listener];\n        delete listeners[event][listener];\n        if (Object.keys(listeners[event]).length === 0) {\n          delete listeners[event];\n        }\n        if (Object.keys(listeners).length === 0) {\n          delete element.listeners;\n        }\n      }\n    }\n    element.removeEventListener(event, handler, options);\n  });\n}\n\n/**\n * Add event listener to the target element.\n * @param {Element} element - The event target.\n * @param {string} type - The event type(s).\n * @param {Function} listener - The event listener.\n * @param {Object} options - The event options.\n */\nfunction addListener(element, type, listener) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _handler = listener;\n  type.trim().split(REGEXP_SPACES).forEach(function (event) {\n    if (options.once && !onceSupported) {\n      var _element$listeners = element.listeners,\n        listeners = _element$listeners === void 0 ? {} : _element$listeners;\n      _handler = function handler() {\n        delete listeners[event][listener];\n        element.removeEventListener(event, _handler, options);\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        listener.apply(element, args);\n      };\n      if (!listeners[event]) {\n        listeners[event] = {};\n      }\n      if (listeners[event][listener]) {\n        element.removeEventListener(event, listeners[event][listener], options);\n      }\n      listeners[event][listener] = _handler;\n      element.listeners = listeners;\n    }\n    element.addEventListener(event, _handler, options);\n  });\n}\n\n/**\n * Dispatch event on the target element.\n * @param {Element} element - The event target.\n * @param {string} type - The event type(s).\n * @param {Object} data - The additional event data.\n * @param {Object} options - The additional event options.\n * @returns {boolean} Indicate if the event is default prevented or not.\n */\nfunction dispatchEvent(element, type, data, options) {\n  var event;\n\n  // Event and CustomEvent on IE9-11 are global objects, not constructors\n  if (isFunction(Event) && isFunction(CustomEvent)) {\n    event = new CustomEvent(type, _objectSpread2({\n      bubbles: true,\n      cancelable: true,\n      detail: data\n    }, options));\n  } else {\n    event = document.createEvent('CustomEvent');\n    event.initCustomEvent(type, true, true, data);\n  }\n  return element.dispatchEvent(event);\n}\n\n/**\n * Get the offset base on the document.\n * @param {Element} element - The target element.\n * @returns {Object} The offset data.\n */\nfunction getOffset(element) {\n  var box = element.getBoundingClientRect();\n  return {\n    left: box.left + (window.pageXOffset - document.documentElement.clientLeft),\n    top: box.top + (window.pageYOffset - document.documentElement.clientTop)\n  };\n}\n\n/**\n * Get transforms base on the given object.\n * @param {Object} obj - The target object.\n * @returns {string} A string contains transform values.\n */\nfunction getTransforms(_ref) {\n  var rotate = _ref.rotate,\n    scaleX = _ref.scaleX,\n    scaleY = _ref.scaleY,\n    translateX = _ref.translateX,\n    translateY = _ref.translateY;\n  var values = [];\n  if (isNumber(translateX) && translateX !== 0) {\n    values.push(\"translateX(\".concat(translateX, \"px)\"));\n  }\n  if (isNumber(translateY) && translateY !== 0) {\n    values.push(\"translateY(\".concat(translateY, \"px)\"));\n  }\n\n  // Rotate should come first before scale to match orientation transform\n  if (isNumber(rotate) && rotate !== 0) {\n    values.push(\"rotate(\".concat(rotate, \"deg)\"));\n  }\n  if (isNumber(scaleX) && scaleX !== 1) {\n    values.push(\"scaleX(\".concat(scaleX, \")\"));\n  }\n  if (isNumber(scaleY) && scaleY !== 1) {\n    values.push(\"scaleY(\".concat(scaleY, \")\"));\n  }\n  var transform = values.length ? values.join(' ') : 'none';\n  return {\n    WebkitTransform: transform,\n    msTransform: transform,\n    transform: transform\n  };\n}\n\n/**\n * Get an image name from an image url.\n * @param {string} url - The target url.\n * @example\n * // picture.jpg\n * getImageNameFromURL('https://domain.com/path/to/picture.jpg?size=1280Ã—960')\n * @returns {string} A string contains the image name.\n */\nfunction getImageNameFromURL(url) {\n  return isString(url) ? decodeURIComponent(url.replace(/^.*\\//, '').replace(/[?&#].*$/, '')) : '';\n}\nvar IS_SAFARI = WINDOW.navigator && /Version\\/\\d+(\\.\\d+)+?\\s+Safari/i.test(WINDOW.navigator.userAgent);\n\n/**\n * Get an image's natural sizes.\n * @param {string} image - The target image.\n * @param {Object} options - The viewer options.\n * @param {Function} callback - The callback function.\n * @returns {HTMLImageElement} The new image.\n */\nfunction getImageNaturalSizes(image, options, callback) {\n  var newImage = document.createElement('img');\n\n  // Modern browsers (except Safari)\n  if (image.naturalWidth && !IS_SAFARI) {\n    callback(image.naturalWidth, image.naturalHeight);\n    return newImage;\n  }\n  var body = document.body || document.documentElement;\n  newImage.onload = function () {\n    callback(newImage.width, newImage.height);\n    if (!IS_SAFARI) {\n      body.removeChild(newImage);\n    }\n  };\n  forEach(options.inheritedAttributes, function (name) {\n    var value = image.getAttribute(name);\n    if (value !== null) {\n      newImage.setAttribute(name, value);\n    }\n  });\n  newImage.src = image.src;\n\n  // iOS Safari will convert the image automatically\n  // with its orientation once append it into DOM\n  if (!IS_SAFARI) {\n    newImage.style.cssText = 'left:0;' + 'max-height:none!important;' + 'max-width:none!important;' + 'min-height:0!important;' + 'min-width:0!important;' + 'opacity:0;' + 'position:absolute;' + 'top:0;' + 'z-index:-1;';\n    body.appendChild(newImage);\n  }\n  return newImage;\n}\n\n/**\n * Get the related class name of a responsive type number.\n * @param {string} type - The responsive type.\n * @returns {string} The related class name.\n */\nfunction getResponsiveClass(type) {\n  switch (type) {\n    case 2:\n      return CLASS_HIDE_XS_DOWN;\n    case 3:\n      return CLASS_HIDE_SM_DOWN;\n    case 4:\n      return CLASS_HIDE_MD_DOWN;\n    default:\n      return '';\n  }\n}\n\n/**\n * Get the max ratio of a group of pointers.\n * @param {string} pointers - The target pointers.\n * @returns {number} The result ratio.\n */\nfunction getMaxZoomRatio(pointers) {\n  var pointers2 = _objectSpread2({}, pointers);\n  var ratios = [];\n  forEach(pointers, function (pointer, pointerId) {\n    delete pointers2[pointerId];\n    forEach(pointers2, function (pointer2) {\n      var x1 = Math.abs(pointer.startX - pointer2.startX);\n      var y1 = Math.abs(pointer.startY - pointer2.startY);\n      var x2 = Math.abs(pointer.endX - pointer2.endX);\n      var y2 = Math.abs(pointer.endY - pointer2.endY);\n      var z1 = Math.sqrt(x1 * x1 + y1 * y1);\n      var z2 = Math.sqrt(x2 * x2 + y2 * y2);\n      var ratio = (z2 - z1) / z1;\n      ratios.push(ratio);\n    });\n  });\n  ratios.sort(function (a, b) {\n    return Math.abs(a) < Math.abs(b);\n  });\n  return ratios[0];\n}\n\n/**\n * Get a pointer from an event object.\n * @param {Object} event - The target event object.\n * @param {boolean} endOnly - Indicates if only returns the end point coordinate or not.\n * @returns {Object} The result pointer contains start and/or end point coordinates.\n */\nfunction getPointer(_ref2, endOnly) {\n  var pageX = _ref2.pageX,\n    pageY = _ref2.pageY;\n  var end = {\n    endX: pageX,\n    endY: pageY\n  };\n  return endOnly ? end : _objectSpread2({\n    timeStamp: Date.now(),\n    startX: pageX,\n    startY: pageY\n  }, end);\n}\n\n/**\n * Get the center point coordinate of a group of pointers.\n * @param {Object} pointers - The target pointers.\n * @returns {Object} The center point coordinate.\n */\nfunction getPointersCenter(pointers) {\n  var pageX = 0;\n  var pageY = 0;\n  var count = 0;\n  forEach(pointers, function (_ref3) {\n    var startX = _ref3.startX,\n      startY = _ref3.startY;\n    pageX += startX;\n    pageY += startY;\n    count += 1;\n  });\n  pageX /= count;\n  pageY /= count;\n  return {\n    pageX: pageX,\n    pageY: pageY\n  };\n}\n\nvar render = {\n  render: function render() {\n    this.initContainer();\n    this.initViewer();\n    this.initList();\n    this.renderViewer();\n  },\n  initBody: function initBody() {\n    var ownerDocument = this.element.ownerDocument;\n    var body = ownerDocument.body || ownerDocument.documentElement;\n    this.body = body;\n    this.scrollbarWidth = window.innerWidth - ownerDocument.documentElement.clientWidth;\n    this.initialBodyPaddingRight = body.style.paddingRight;\n    this.initialBodyComputedPaddingRight = window.getComputedStyle(body).paddingRight;\n  },\n  initContainer: function initContainer() {\n    this.containerData = {\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n  },\n  initViewer: function initViewer() {\n    var options = this.options,\n      parent = this.parent;\n    var viewerData;\n    if (options.inline) {\n      viewerData = {\n        width: Math.max(parent.offsetWidth, options.minWidth),\n        height: Math.max(parent.offsetHeight, options.minHeight)\n      };\n      this.parentData = viewerData;\n    }\n    if (this.fulled || !viewerData) {\n      viewerData = this.containerData;\n    }\n    this.viewerData = assign({}, viewerData);\n  },\n  renderViewer: function renderViewer() {\n    if (this.options.inline && !this.fulled) {\n      setStyle(this.viewer, this.viewerData);\n    }\n  },\n  initList: function initList() {\n    var _this = this;\n    var element = this.element,\n      options = this.options,\n      list = this.list;\n    var items = [];\n\n    // initList may be called in this.update, so should keep idempotent\n    list.innerHTML = '';\n    forEach(this.images, function (image, index) {\n      var src = image.src;\n      var alt = image.alt || getImageNameFromURL(src);\n      var url = _this.getImageURL(image);\n      if (src || url) {\n        var item = document.createElement('li');\n        var img = document.createElement('img');\n        forEach(options.inheritedAttributes, function (name) {\n          var value = image.getAttribute(name);\n          if (value !== null) {\n            img.setAttribute(name, value);\n          }\n        });\n        if (options.navbar) {\n          img.src = src || url;\n        }\n        img.alt = alt;\n        img.setAttribute('data-original-url', url || src);\n        item.setAttribute('data-index', index);\n        item.setAttribute('data-viewer-action', 'view');\n        item.setAttribute('role', 'button');\n        if (options.keyboard) {\n          item.setAttribute('tabindex', 0);\n        }\n        item.appendChild(img);\n        list.appendChild(item);\n        items.push(item);\n      }\n    });\n    this.items = items;\n    forEach(items, function (item) {\n      var image = item.firstElementChild;\n      var onLoad;\n      var onError;\n      setData(image, 'filled', true);\n      if (options.loading) {\n        addClass(item, CLASS_LOADING);\n      }\n      addListener(image, EVENT_LOAD, onLoad = function onLoad(event) {\n        removeListener(image, EVENT_ERROR, onError);\n        if (options.loading) {\n          removeClass(item, CLASS_LOADING);\n        }\n        _this.loadImage(event);\n      }, {\n        once: true\n      });\n      addListener(image, EVENT_ERROR, onError = function onError() {\n        removeListener(image, EVENT_LOAD, onLoad);\n        if (options.loading) {\n          removeClass(item, CLASS_LOADING);\n        }\n      }, {\n        once: true\n      });\n    });\n    if (options.transition) {\n      addListener(element, EVENT_VIEWED, function () {\n        addClass(list, CLASS_TRANSITION);\n      }, {\n        once: true\n      });\n    }\n  },\n  renderList: function renderList() {\n    var index = this.index;\n    var item = this.items[index];\n    if (!item) {\n      return;\n    }\n    var next = item.nextElementSibling;\n    var gutter = parseInt(window.getComputedStyle(next || item).marginLeft, 10);\n    var offsetWidth = item.offsetWidth;\n    var outerWidth = offsetWidth + gutter;\n\n    // Place the active item in the center of the screen\n    setStyle(this.list, assign({\n      width: outerWidth * this.length - gutter\n    }, getTransforms({\n      translateX: (this.viewerData.width - offsetWidth) / 2 - outerWidth * index\n    })));\n  },\n  resetList: function resetList() {\n    var list = this.list;\n    list.innerHTML = '';\n    removeClass(list, CLASS_TRANSITION);\n    setStyle(list, getTransforms({\n      translateX: 0\n    }));\n  },\n  initImage: function initImage(done) {\n    var _this2 = this;\n    var options = this.options,\n      image = this.image,\n      viewerData = this.viewerData;\n    var footerHeight = this.footer.offsetHeight;\n    var viewerWidth = viewerData.width;\n    var viewerHeight = Math.max(viewerData.height - footerHeight, footerHeight);\n    var oldImageData = this.imageData || {};\n    var sizingImage;\n    this.imageInitializing = {\n      abort: function abort() {\n        sizingImage.onload = null;\n      }\n    };\n    sizingImage = getImageNaturalSizes(image, options, function (naturalWidth, naturalHeight) {\n      var aspectRatio = naturalWidth / naturalHeight;\n      var initialCoverage = Math.max(0, Math.min(1, options.initialCoverage));\n      var width = viewerWidth;\n      var height = viewerHeight;\n      _this2.imageInitializing = false;\n      if (viewerHeight * aspectRatio > viewerWidth) {\n        height = viewerWidth / aspectRatio;\n      } else {\n        width = viewerHeight * aspectRatio;\n      }\n      initialCoverage = isNumber(initialCoverage) ? initialCoverage : 0.9;\n      width = Math.min(width * initialCoverage, naturalWidth);\n      height = Math.min(height * initialCoverage, naturalHeight);\n      var left = (viewerWidth - width) / 2;\n      var top = (viewerHeight - height) / 2;\n      var imageData = {\n        left: left,\n        top: top,\n        x: left,\n        y: top,\n        width: width,\n        height: height,\n        oldRatio: 1,\n        ratio: width / naturalWidth,\n        aspectRatio: aspectRatio,\n        naturalWidth: naturalWidth,\n        naturalHeight: naturalHeight\n      };\n      var initialImageData = assign({}, imageData);\n      if (options.rotatable) {\n        imageData.rotate = oldImageData.rotate || 0;\n        initialImageData.rotate = 0;\n      }\n      if (options.scalable) {\n        imageData.scaleX = oldImageData.scaleX || 1;\n        imageData.scaleY = oldImageData.scaleY || 1;\n        initialImageData.scaleX = 1;\n        initialImageData.scaleY = 1;\n      }\n      _this2.imageData = imageData;\n      _this2.initialImageData = initialImageData;\n      if (done) {\n        done();\n      }\n    });\n  },\n  renderImage: function renderImage(done) {\n    var _this3 = this;\n    var image = this.image,\n      imageData = this.imageData;\n    setStyle(image, assign({\n      width: imageData.width,\n      height: imageData.height,\n      // XXX: Not to use translateX/Y to avoid image shaking when zooming\n      marginLeft: imageData.x,\n      marginTop: imageData.y\n    }, getTransforms(imageData)));\n    if (done) {\n      if ((this.viewing || this.moving || this.rotating || this.scaling || this.zooming) && this.options.transition && hasClass(image, CLASS_TRANSITION)) {\n        var onTransitionEnd = function onTransitionEnd() {\n          _this3.imageRendering = false;\n          done();\n        };\n        this.imageRendering = {\n          abort: function abort() {\n            removeListener(image, EVENT_TRANSITION_END, onTransitionEnd);\n          }\n        };\n        addListener(image, EVENT_TRANSITION_END, onTransitionEnd, {\n          once: true\n        });\n      } else {\n        done();\n      }\n    }\n  },\n  resetImage: function resetImage() {\n    var image = this.image;\n    if (image) {\n      if (this.viewing) {\n        this.viewing.abort();\n      }\n      image.parentNode.removeChild(image);\n      this.image = null;\n      this.title.innerHTML = '';\n    }\n  }\n};\n\nvar events = {\n  bind: function bind() {\n    var options = this.options,\n      viewer = this.viewer,\n      canvas = this.canvas;\n    var document = this.element.ownerDocument;\n    addListener(viewer, EVENT_CLICK, this.onClick = this.click.bind(this));\n    addListener(viewer, EVENT_DRAG_START, this.onDragStart = this.dragstart.bind(this));\n    addListener(canvas, EVENT_POINTER_DOWN, this.onPointerDown = this.pointerdown.bind(this));\n    addListener(document, EVENT_POINTER_MOVE, this.onPointerMove = this.pointermove.bind(this));\n    addListener(document, EVENT_POINTER_UP, this.onPointerUp = this.pointerup.bind(this));\n    addListener(document, EVENT_KEY_DOWN, this.onKeyDown = this.keydown.bind(this));\n    addListener(window, EVENT_RESIZE, this.onResize = this.resize.bind(this));\n    if (options.zoomable && options.zoomOnWheel) {\n      addListener(viewer, EVENT_WHEEL, this.onWheel = this.wheel.bind(this), {\n        passive: false,\n        capture: true\n      });\n    }\n    if (options.toggleOnDblclick) {\n      addListener(canvas, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this));\n    }\n  },\n  unbind: function unbind() {\n    var options = this.options,\n      viewer = this.viewer,\n      canvas = this.canvas;\n    var document = this.element.ownerDocument;\n    removeListener(viewer, EVENT_CLICK, this.onClick);\n    removeListener(viewer, EVENT_DRAG_START, this.onDragStart);\n    removeListener(canvas, EVENT_POINTER_DOWN, this.onPointerDown);\n    removeListener(document, EVENT_POINTER_MOVE, this.onPointerMove);\n    removeListener(document, EVENT_POINTER_UP, this.onPointerUp);\n    removeListener(document, EVENT_KEY_DOWN, this.onKeyDown);\n    removeListener(window, EVENT_RESIZE, this.onResize);\n    if (options.zoomable && options.zoomOnWheel) {\n      removeListener(viewer, EVENT_WHEEL, this.onWheel, {\n        passive: false,\n        capture: true\n      });\n    }\n    if (options.toggleOnDblclick) {\n      removeListener(canvas, EVENT_DBLCLICK, this.onDblclick);\n    }\n  }\n};\n\nvar handlers = {\n  click: function click(event) {\n    var options = this.options,\n      imageData = this.imageData;\n    var target = event.target;\n    var action = getData(target, DATA_ACTION);\n    if (!action && target.localName === 'img' && target.parentElement.localName === 'li') {\n      target = target.parentElement;\n      action = getData(target, DATA_ACTION);\n    }\n\n    // Cancel the emulated click when the native click event was triggered.\n    if (IS_TOUCH_DEVICE && event.isTrusted && target === this.canvas) {\n      clearTimeout(this.clickCanvasTimeout);\n    }\n    switch (action) {\n      case 'mix':\n        if (this.played) {\n          this.stop();\n        } else if (options.inline) {\n          if (this.fulled) {\n            this.exit();\n          } else {\n            this.full();\n          }\n        } else {\n          this.hide();\n        }\n        break;\n      case 'hide':\n        if (!this.pointerMoved) {\n          this.hide();\n        }\n        break;\n      case 'view':\n        this.view(getData(target, 'index'));\n        break;\n      case 'zoom-in':\n        this.zoom(0.1, true);\n        break;\n      case 'zoom-out':\n        this.zoom(-0.1, true);\n        break;\n      case 'one-to-one':\n        this.toggle();\n        break;\n      case 'reset':\n        this.reset();\n        break;\n      case 'prev':\n        this.prev(options.loop);\n        break;\n      case 'play':\n        this.play(options.fullscreen);\n        break;\n      case 'next':\n        this.next(options.loop);\n        break;\n      case 'rotate-left':\n        this.rotate(-90);\n        break;\n      case 'rotate-right':\n        this.rotate(90);\n        break;\n      case 'flip-horizontal':\n        this.scaleX(-imageData.scaleX || -1);\n        break;\n      case 'flip-vertical':\n        this.scaleY(-imageData.scaleY || -1);\n        break;\n      default:\n        if (this.played) {\n          this.stop();\n        }\n    }\n  },\n  dblclick: function dblclick(event) {\n    event.preventDefault();\n    if (this.viewed && event.target === this.image) {\n      // Cancel the emulated double click when the native dblclick event was triggered.\n      if (IS_TOUCH_DEVICE && event.isTrusted) {\n        clearTimeout(this.doubleClickImageTimeout);\n      }\n\n      // XXX: No pageX/Y properties in custom event, fallback to the original event.\n      this.toggle(event.isTrusted ? event : event.detail && event.detail.originalEvent);\n    }\n  },\n  load: function load() {\n    var _this = this;\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n      this.timeout = false;\n    }\n    var element = this.element,\n      options = this.options,\n      image = this.image,\n      index = this.index,\n      viewerData = this.viewerData;\n    removeClass(image, CLASS_INVISIBLE);\n    if (options.loading) {\n      removeClass(this.canvas, CLASS_LOADING);\n    }\n    image.style.cssText = 'height:0;' + \"margin-left:\".concat(viewerData.width / 2, \"px;\") + \"margin-top:\".concat(viewerData.height / 2, \"px;\") + 'max-width:none!important;' + 'position:relative;' + 'width:0;';\n    this.initImage(function () {\n      toggleClass(image, CLASS_MOVE, options.movable);\n      toggleClass(image, CLASS_TRANSITION, options.transition);\n      _this.renderImage(function () {\n        _this.viewed = true;\n        _this.viewing = false;\n        if (isFunction(options.viewed)) {\n          addListener(element, EVENT_VIEWED, options.viewed, {\n            once: true\n          });\n        }\n        dispatchEvent(element, EVENT_VIEWED, {\n          originalImage: _this.images[index],\n          index: index,\n          image: image\n        }, {\n          cancelable: false\n        });\n      });\n    });\n  },\n  loadImage: function loadImage(event) {\n    var image = event.target;\n    var parent = image.parentNode;\n    var parentWidth = parent.offsetWidth || 30;\n    var parentHeight = parent.offsetHeight || 50;\n    var filled = !!getData(image, 'filled');\n    getImageNaturalSizes(image, this.options, function (naturalWidth, naturalHeight) {\n      var aspectRatio = naturalWidth / naturalHeight;\n      var width = parentWidth;\n      var height = parentHeight;\n      if (parentHeight * aspectRatio > parentWidth) {\n        if (filled) {\n          width = parentHeight * aspectRatio;\n        } else {\n          height = parentWidth / aspectRatio;\n        }\n      } else if (filled) {\n        height = parentWidth / aspectRatio;\n      } else {\n        width = parentHeight * aspectRatio;\n      }\n      setStyle(image, assign({\n        width: width,\n        height: height\n      }, getTransforms({\n        translateX: (parentWidth - width) / 2,\n        translateY: (parentHeight - height) / 2\n      })));\n    });\n  },\n  keydown: function keydown(event) {\n    var options = this.options;\n    if (!options.keyboard) {\n      return;\n    }\n    var keyCode = event.keyCode || event.which || event.charCode;\n    switch (keyCode) {\n      // Enter\n      case 13:\n        if (this.viewer.contains(event.target)) {\n          this.click(event);\n        }\n        break;\n    }\n    if (!this.fulled) {\n      return;\n    }\n    switch (keyCode) {\n      // Escape\n      case 27:\n        if (this.played) {\n          this.stop();\n        } else if (options.inline) {\n          if (this.fulled) {\n            this.exit();\n          }\n        } else {\n          this.hide();\n        }\n        break;\n\n      // Space\n      case 32:\n        if (this.played) {\n          this.stop();\n        }\n        break;\n\n      // ArrowLeft\n      case 37:\n        if (this.played && this.playing) {\n          this.playing.prev();\n        } else {\n          this.prev(options.loop);\n        }\n        break;\n\n      // ArrowUp\n      case 38:\n        // Prevent scroll on Firefox\n        event.preventDefault();\n\n        // Zoom in\n        this.zoom(options.zoomRatio, true);\n        break;\n\n      // ArrowRight\n      case 39:\n        if (this.played && this.playing) {\n          this.playing.next();\n        } else {\n          this.next(options.loop);\n        }\n        break;\n\n      // ArrowDown\n      case 40:\n        // Prevent scroll on Firefox\n        event.preventDefault();\n\n        // Zoom out\n        this.zoom(-options.zoomRatio, true);\n        break;\n\n      // Ctrl + 0\n      case 48:\n      // Fall through\n\n      // Ctrl + 1\n      // eslint-disable-next-line no-fallthrough\n      case 49:\n        if (event.ctrlKey) {\n          event.preventDefault();\n          this.toggle();\n        }\n        break;\n    }\n  },\n  dragstart: function dragstart(event) {\n    if (event.target.localName === 'img') {\n      event.preventDefault();\n    }\n  },\n  pointerdown: function pointerdown(event) {\n    var options = this.options,\n      pointers = this.pointers;\n    var buttons = event.buttons,\n      button = event.button;\n    this.pointerMoved = false;\n    if (!this.viewed || this.showing || this.viewing || this.hiding\n\n    // Handle mouse event and pointer event and ignore touch event\n    || (event.type === 'mousedown' || event.type === 'pointerdown' && event.pointerType === 'mouse') && (\n    // No primary button (Usually the left button)\n    isNumber(buttons) && buttons !== 1 || isNumber(button) && button !== 0\n\n    // Open context menu\n    || event.ctrlKey)) {\n      return;\n    }\n\n    // Prevent default behaviours as page zooming in touch devices.\n    event.preventDefault();\n    if (event.changedTouches) {\n      forEach(event.changedTouches, function (touch) {\n        pointers[touch.identifier] = getPointer(touch);\n      });\n    } else {\n      pointers[event.pointerId || 0] = getPointer(event);\n    }\n    var action = options.movable ? ACTION_MOVE : false;\n    if (options.zoomOnTouch && options.zoomable && Object.keys(pointers).length > 1) {\n      action = ACTION_ZOOM;\n    } else if (options.slideOnTouch && (event.pointerType === 'touch' || event.type === 'touchstart') && this.isSwitchable()) {\n      action = ACTION_SWITCH;\n    }\n    if (options.transition && (action === ACTION_MOVE || action === ACTION_ZOOM)) {\n      removeClass(this.image, CLASS_TRANSITION);\n    }\n    this.action = action;\n  },\n  pointermove: function pointermove(event) {\n    var pointers = this.pointers,\n      action = this.action;\n    if (!this.viewed || !action) {\n      return;\n    }\n    event.preventDefault();\n    if (event.changedTouches) {\n      forEach(event.changedTouches, function (touch) {\n        assign(pointers[touch.identifier] || {}, getPointer(touch, true));\n      });\n    } else {\n      assign(pointers[event.pointerId || 0] || {}, getPointer(event, true));\n    }\n    this.change(event);\n  },\n  pointerup: function pointerup(event) {\n    var _this2 = this;\n    var options = this.options,\n      action = this.action,\n      pointers = this.pointers;\n    var pointer;\n    if (event.changedTouches) {\n      forEach(event.changedTouches, function (touch) {\n        pointer = pointers[touch.identifier];\n        delete pointers[touch.identifier];\n      });\n    } else {\n      pointer = pointers[event.pointerId || 0];\n      delete pointers[event.pointerId || 0];\n    }\n    if (!action) {\n      return;\n    }\n    event.preventDefault();\n    if (options.transition && (action === ACTION_MOVE || action === ACTION_ZOOM)) {\n      addClass(this.image, CLASS_TRANSITION);\n    }\n    this.action = false;\n\n    // Emulate click and double click in touch devices to support backdrop and image zooming (#210).\n    if (IS_TOUCH_DEVICE && action !== ACTION_ZOOM && pointer && Date.now() - pointer.timeStamp < 500) {\n      clearTimeout(this.clickCanvasTimeout);\n      clearTimeout(this.doubleClickImageTimeout);\n      if (options.toggleOnDblclick && this.viewed && event.target === this.image) {\n        if (this.imageClicked) {\n          this.imageClicked = false;\n\n          // This timeout will be cleared later when a native dblclick event is triggering\n          this.doubleClickImageTimeout = setTimeout(function () {\n            dispatchEvent(_this2.image, EVENT_DBLCLICK, {\n              originalEvent: event\n            });\n          }, 50);\n        } else {\n          this.imageClicked = true;\n\n          // The default timing of a double click in Windows is 500 ms\n          this.doubleClickImageTimeout = setTimeout(function () {\n            _this2.imageClicked = false;\n          }, 500);\n        }\n      } else {\n        this.imageClicked = false;\n        if (options.backdrop && options.backdrop !== 'static' && event.target === this.canvas) {\n          // This timeout will be cleared later when a native click event is triggering\n          this.clickCanvasTimeout = setTimeout(function () {\n            dispatchEvent(_this2.canvas, EVENT_CLICK, {\n              originalEvent: event\n            });\n          }, 50);\n        }\n      }\n    }\n  },\n  resize: function resize() {\n    var _this3 = this;\n    if (!this.isShown || this.hiding) {\n      return;\n    }\n    if (this.fulled) {\n      this.close();\n      this.initBody();\n      this.open();\n    }\n    this.initContainer();\n    this.initViewer();\n    this.renderViewer();\n    this.renderList();\n    if (this.viewed) {\n      this.initImage(function () {\n        _this3.renderImage();\n      });\n    }\n    if (this.played) {\n      if (this.options.fullscreen && this.fulled && !(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {\n        this.stop();\n        return;\n      }\n      forEach(this.player.getElementsByTagName('img'), function (image) {\n        addListener(image, EVENT_LOAD, _this3.loadImage.bind(_this3), {\n          once: true\n        });\n        dispatchEvent(image, EVENT_LOAD);\n      });\n    }\n  },\n  wheel: function wheel(event) {\n    var _this4 = this;\n    if (!this.viewed) {\n      return;\n    }\n    event.preventDefault();\n\n    // Limit wheel speed to prevent zoom too fast\n    if (this.wheeling) {\n      return;\n    }\n    this.wheeling = true;\n    setTimeout(function () {\n      _this4.wheeling = false;\n    }, 50);\n    var ratio = Number(this.options.zoomRatio) || 0.1;\n    var delta = 1;\n    if (event.deltaY) {\n      delta = event.deltaY > 0 ? 1 : -1;\n    } else if (event.wheelDelta) {\n      delta = -event.wheelDelta / 120;\n    } else if (event.detail) {\n      delta = event.detail > 0 ? 1 : -1;\n    }\n    this.zoom(-delta * ratio, true, null, event);\n  }\n};\n\nvar methods = {\n  /** Show the viewer (only available in modal mode)\n   * @param {boolean} [immediate=false] - Indicates if show the viewer immediately or not.\n   * @returns {Viewer} this\n   */\n  show: function show() {\n    var immediate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var element = this.element,\n      options = this.options;\n    if (options.inline || this.showing || this.isShown || this.showing) {\n      return this;\n    }\n    if (!this.ready) {\n      this.build();\n      if (this.ready) {\n        this.show(immediate);\n      }\n      return this;\n    }\n    if (isFunction(options.show)) {\n      addListener(element, EVENT_SHOW, options.show, {\n        once: true\n      });\n    }\n    if (dispatchEvent(element, EVENT_SHOW) === false || !this.ready) {\n      return this;\n    }\n    if (this.hiding) {\n      this.transitioning.abort();\n    }\n    this.showing = true;\n    this.open();\n    var viewer = this.viewer;\n    removeClass(viewer, CLASS_HIDE);\n    viewer.setAttribute('role', 'dialog');\n    viewer.setAttribute('aria-labelledby', this.title.id);\n    viewer.setAttribute('aria-modal', true);\n    viewer.removeAttribute('aria-hidden');\n    if (options.transition && !immediate) {\n      var shown = this.shown.bind(this);\n      this.transitioning = {\n        abort: function abort() {\n          removeListener(viewer, EVENT_TRANSITION_END, shown);\n          removeClass(viewer, CLASS_IN);\n        }\n      };\n      addClass(viewer, CLASS_TRANSITION);\n\n      // Force reflow to enable CSS3 transition\n      viewer.initialOffsetWidth = viewer.offsetWidth;\n      addListener(viewer, EVENT_TRANSITION_END, shown, {\n        once: true\n      });\n      addClass(viewer, CLASS_IN);\n    } else {\n      addClass(viewer, CLASS_IN);\n      this.shown();\n    }\n    return this;\n  },\n  /**\n   * Hide the viewer (only available in modal mode)\n   * @param {boolean} [immediate=false] - Indicates if hide the viewer immediately or not.\n   * @returns {Viewer} this\n   */\n  hide: function hide() {\n    var _this = this;\n    var immediate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var element = this.element,\n      options = this.options;\n    if (options.inline || this.hiding || !(this.isShown || this.showing)) {\n      return this;\n    }\n    if (isFunction(options.hide)) {\n      addListener(element, EVENT_HIDE, options.hide, {\n        once: true\n      });\n    }\n    if (dispatchEvent(element, EVENT_HIDE) === false) {\n      return this;\n    }\n    if (this.showing) {\n      this.transitioning.abort();\n    }\n    this.hiding = true;\n    if (this.played) {\n      this.stop();\n    } else if (this.viewing) {\n      this.viewing.abort();\n    }\n    var viewer = this.viewer,\n      image = this.image;\n    var hideImmediately = function hideImmediately() {\n      removeClass(viewer, CLASS_IN);\n      _this.hidden();\n    };\n    if (options.transition && !immediate) {\n      var onViewerTransitionEnd = function onViewerTransitionEnd(event) {\n        // Ignore all propagating `transitionend` events (#275).\n        if (event && event.target === viewer) {\n          removeListener(viewer, EVENT_TRANSITION_END, onViewerTransitionEnd);\n          _this.hidden();\n        }\n      };\n      var onImageTransitionEnd = function onImageTransitionEnd() {\n        // In case of show the viewer by `viewer.show(true)` previously (#407).\n        if (hasClass(viewer, CLASS_TRANSITION)) {\n          addListener(viewer, EVENT_TRANSITION_END, onViewerTransitionEnd);\n          removeClass(viewer, CLASS_IN);\n        } else {\n          hideImmediately();\n        }\n      };\n      this.transitioning = {\n        abort: function abort() {\n          if (_this.viewed && hasClass(image, CLASS_TRANSITION)) {\n            removeListener(image, EVENT_TRANSITION_END, onImageTransitionEnd);\n          } else if (hasClass(viewer, CLASS_TRANSITION)) {\n            removeListener(viewer, EVENT_TRANSITION_END, onViewerTransitionEnd);\n          }\n        }\n      };\n\n      // In case of hiding the viewer when holding on the image (#255),\n      // note that the `CLASS_TRANSITION` class will be removed on pointer down.\n      if (this.viewed && hasClass(image, CLASS_TRANSITION)) {\n        addListener(image, EVENT_TRANSITION_END, onImageTransitionEnd, {\n          once: true\n        });\n        this.zoomTo(0, false, null, null, true);\n      } else {\n        onImageTransitionEnd();\n      }\n    } else {\n      hideImmediately();\n    }\n    return this;\n  },\n  /**\n   * View one of the images with image's index\n   * @param {number} index - The index of the image to view.\n   * @returns {Viewer} this\n   */\n  view: function view() {\n    var _this2 = this;\n    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.initialViewIndex;\n    index = Number(index) || 0;\n    if (this.hiding || this.played || index < 0 || index >= this.length || this.viewed && index === this.index) {\n      return this;\n    }\n    if (!this.isShown) {\n      this.index = index;\n      return this.show();\n    }\n    if (this.viewing) {\n      this.viewing.abort();\n    }\n    var element = this.element,\n      options = this.options,\n      title = this.title,\n      canvas = this.canvas;\n    var item = this.items[index];\n    var img = item.querySelector('img');\n    var url = getData(img, 'originalUrl');\n    var alt = img.getAttribute('alt');\n    var image = document.createElement('img');\n    forEach(options.inheritedAttributes, function (name) {\n      var value = img.getAttribute(name);\n      if (value !== null) {\n        image.setAttribute(name, value);\n      }\n    });\n    image.src = url;\n    image.alt = alt;\n    if (isFunction(options.view)) {\n      addListener(element, EVENT_VIEW, options.view, {\n        once: true\n      });\n    }\n    if (dispatchEvent(element, EVENT_VIEW, {\n      originalImage: this.images[index],\n      index: index,\n      image: image\n    }) === false || !this.isShown || this.hiding || this.played) {\n      return this;\n    }\n    var activeItem = this.items[this.index];\n    if (activeItem) {\n      removeClass(activeItem, CLASS_ACTIVE);\n      activeItem.removeAttribute('aria-selected');\n    }\n    addClass(item, CLASS_ACTIVE);\n    item.setAttribute('aria-selected', true);\n    if (options.focus) {\n      item.focus();\n    }\n    this.image = image;\n    this.viewed = false;\n    this.index = index;\n    this.imageData = {};\n    addClass(image, CLASS_INVISIBLE);\n    if (options.loading) {\n      addClass(canvas, CLASS_LOADING);\n    }\n    canvas.innerHTML = '';\n    canvas.appendChild(image);\n\n    // Center current item\n    this.renderList();\n\n    // Clear title\n    title.innerHTML = '';\n\n    // Generate title after viewed\n    var onViewed = function onViewed() {\n      var imageData = _this2.imageData;\n      var render = Array.isArray(options.title) ? options.title[1] : options.title;\n      title.innerHTML = escapeHTMLEntities(isFunction(render) ? render.call(_this2, image, imageData) : \"\".concat(alt, \" (\").concat(imageData.naturalWidth, \" \\xD7 \").concat(imageData.naturalHeight, \")\"));\n    };\n    var onLoad;\n    var onError;\n    addListener(element, EVENT_VIEWED, onViewed, {\n      once: true\n    });\n    this.viewing = {\n      abort: function abort() {\n        removeListener(element, EVENT_VIEWED, onViewed);\n        if (image.complete) {\n          if (_this2.imageRendering) {\n            _this2.imageRendering.abort();\n          } else if (_this2.imageInitializing) {\n            _this2.imageInitializing.abort();\n          }\n        } else {\n          // Cancel download to save bandwidth.\n          image.src = '';\n          removeListener(image, EVENT_LOAD, onLoad);\n          if (_this2.timeout) {\n            clearTimeout(_this2.timeout);\n          }\n        }\n      }\n    };\n    if (image.complete) {\n      this.load();\n    } else {\n      addListener(image, EVENT_LOAD, onLoad = function onLoad() {\n        removeListener(image, EVENT_ERROR, onError);\n        _this2.load();\n      }, {\n        once: true\n      });\n      addListener(image, EVENT_ERROR, onError = function onError() {\n        removeListener(image, EVENT_LOAD, onLoad);\n        if (_this2.timeout) {\n          clearTimeout(_this2.timeout);\n          _this2.timeout = false;\n        }\n        removeClass(image, CLASS_INVISIBLE);\n        if (options.loading) {\n          removeClass(_this2.canvas, CLASS_LOADING);\n        }\n      }, {\n        once: true\n      });\n      if (this.timeout) {\n        clearTimeout(this.timeout);\n      }\n\n      // Make the image visible if it fails to load within 1s\n      this.timeout = setTimeout(function () {\n        removeClass(image, CLASS_INVISIBLE);\n        _this2.timeout = false;\n      }, 1000);\n    }\n    return this;\n  },\n  /**\n   * View the previous image\n   * @param {boolean} [loop=false] - Indicate if view the last one\n   * when it is the first one at present.\n   * @returns {Viewer} this\n   */\n  prev: function prev() {\n    var loop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var index = this.index - 1;\n    if (index < 0) {\n      index = loop ? this.length - 1 : 0;\n    }\n    this.view(index);\n    return this;\n  },\n  /**\n   * View the next image\n   * @param {boolean} [loop=false] - Indicate if view the first one\n   * when it is the last one at present.\n   * @returns {Viewer} this\n   */\n  next: function next() {\n    var loop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var maxIndex = this.length - 1;\n    var index = this.index + 1;\n    if (index > maxIndex) {\n      index = loop ? 0 : maxIndex;\n    }\n    this.view(index);\n    return this;\n  },\n  /**\n   * Move the image with relative offsets.\n   * @param {number} x - The moving distance in the horizontal direction.\n   * @param {number} [y=x] The moving distance in the vertical direction.\n   * @returns {Viewer} this\n   */\n  move: function move(x) {\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n    var imageData = this.imageData;\n    this.moveTo(isUndefined(x) ? x : imageData.x + Number(x), isUndefined(y) ? y : imageData.y + Number(y));\n    return this;\n  },\n  /**\n   * Move the image to an absolute point.\n   * @param {number} x - The new position in the horizontal direction.\n   * @param {number} [y=x] - The new position in the vertical direction.\n   * @param {Event} [_originalEvent=null] - The original event if any.\n   * @returns {Viewer} this\n   */\n  moveTo: function moveTo(x) {\n    var _this3 = this;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n    var _originalEvent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var element = this.element,\n      options = this.options,\n      imageData = this.imageData;\n    x = Number(x);\n    y = Number(y);\n    if (this.viewed && !this.played && options.movable) {\n      var oldX = imageData.x;\n      var oldY = imageData.y;\n      var changed = false;\n      if (isNumber(x)) {\n        changed = true;\n      } else {\n        x = oldX;\n      }\n      if (isNumber(y)) {\n        changed = true;\n      } else {\n        y = oldY;\n      }\n      if (changed) {\n        if (isFunction(options.move)) {\n          addListener(element, EVENT_MOVE, options.move, {\n            once: true\n          });\n        }\n        if (dispatchEvent(element, EVENT_MOVE, {\n          x: x,\n          y: y,\n          oldX: oldX,\n          oldY: oldY,\n          originalEvent: _originalEvent\n        }) === false) {\n          return this;\n        }\n        imageData.x = x;\n        imageData.y = y;\n        imageData.left = x;\n        imageData.top = y;\n        this.moving = true;\n        this.renderImage(function () {\n          _this3.moving = false;\n          if (isFunction(options.moved)) {\n            addListener(element, EVENT_MOVED, options.moved, {\n              once: true\n            });\n          }\n          dispatchEvent(element, EVENT_MOVED, {\n            x: x,\n            y: y,\n            oldX: oldX,\n            oldY: oldY,\n            originalEvent: _originalEvent\n          }, {\n            cancelable: false\n          });\n        });\n      }\n    }\n    return this;\n  },\n  /**\n   * Rotate the image with a relative degree.\n   * @param {number} degree - The rotate degree.\n   * @returns {Viewer} this\n   */\n  rotate: function rotate(degree) {\n    this.rotateTo((this.imageData.rotate || 0) + Number(degree));\n    return this;\n  },\n  /**\n   * Rotate the image to an absolute degree.\n   * @param {number} degree - The rotate degree.\n   * @returns {Viewer} this\n   */\n  rotateTo: function rotateTo(degree) {\n    var _this4 = this;\n    var element = this.element,\n      options = this.options,\n      imageData = this.imageData;\n    degree = Number(degree);\n    if (isNumber(degree) && this.viewed && !this.played && options.rotatable) {\n      var oldDegree = imageData.rotate;\n      if (isFunction(options.rotate)) {\n        addListener(element, EVENT_ROTATE, options.rotate, {\n          once: true\n        });\n      }\n      if (dispatchEvent(element, EVENT_ROTATE, {\n        degree: degree,\n        oldDegree: oldDegree\n      }) === false) {\n        return this;\n      }\n      imageData.rotate = degree;\n      this.rotating = true;\n      this.renderImage(function () {\n        _this4.rotating = false;\n        if (isFunction(options.rotated)) {\n          addListener(element, EVENT_ROTATED, options.rotated, {\n            once: true\n          });\n        }\n        dispatchEvent(element, EVENT_ROTATED, {\n          degree: degree,\n          oldDegree: oldDegree\n        }, {\n          cancelable: false\n        });\n      });\n    }\n    return this;\n  },\n  /**\n   * Scale the image on the x-axis.\n   * @param {number} scaleX - The scale ratio on the x-axis.\n   * @returns {Viewer} this\n   */\n  scaleX: function scaleX(_scaleX) {\n    this.scale(_scaleX, this.imageData.scaleY);\n    return this;\n  },\n  /**\n   * Scale the image on the y-axis.\n   * @param {number} scaleY - The scale ratio on the y-axis.\n   * @returns {Viewer} this\n   */\n  scaleY: function scaleY(_scaleY) {\n    this.scale(this.imageData.scaleX, _scaleY);\n    return this;\n  },\n  /**\n   * Scale the image.\n   * @param {number} scaleX - The scale ratio on the x-axis.\n   * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.\n   * @returns {Viewer} this\n   */\n  scale: function scale(scaleX) {\n    var _this5 = this;\n    var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;\n    var element = this.element,\n      options = this.options,\n      imageData = this.imageData;\n    scaleX = Number(scaleX);\n    scaleY = Number(scaleY);\n    if (this.viewed && !this.played && options.scalable) {\n      var oldScaleX = imageData.scaleX;\n      var oldScaleY = imageData.scaleY;\n      var changed = false;\n      if (isNumber(scaleX)) {\n        changed = true;\n      } else {\n        scaleX = oldScaleX;\n      }\n      if (isNumber(scaleY)) {\n        changed = true;\n      } else {\n        scaleY = oldScaleY;\n      }\n      if (changed) {\n        if (isFunction(options.scale)) {\n          addListener(element, EVENT_SCALE, options.scale, {\n            once: true\n          });\n        }\n        if (dispatchEvent(element, EVENT_SCALE, {\n          scaleX: scaleX,\n          scaleY: scaleY,\n          oldScaleX: oldScaleX,\n          oldScaleY: oldScaleY\n        }) === false) {\n          return this;\n        }\n        imageData.scaleX = scaleX;\n        imageData.scaleY = scaleY;\n        this.scaling = true;\n        this.renderImage(function () {\n          _this5.scaling = false;\n          if (isFunction(options.scaled)) {\n            addListener(element, EVENT_SCALED, options.scaled, {\n              once: true\n            });\n          }\n          dispatchEvent(element, EVENT_SCALED, {\n            scaleX: scaleX,\n            scaleY: scaleY,\n            oldScaleX: oldScaleX,\n            oldScaleY: oldScaleY\n          }, {\n            cancelable: false\n          });\n        });\n      }\n    }\n    return this;\n  },\n  /**\n   * Zoom the image with a relative ratio.\n   * @param {number} ratio - The target ratio.\n   * @param {boolean} [showTooltip=false] - Indicates whether to show the tooltip.\n   * @param {Object} [pivot] - The pivot point coordinate for zooming.\n   * @param {Event} [_originalEvent=null] - The original event if any.\n   * @returns {Viewer} this\n   */\n  zoom: function zoom(ratio) {\n    var showTooltip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var pivot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var _originalEvent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var imageData = this.imageData;\n    ratio = Number(ratio);\n    if (ratio < 0) {\n      ratio = 1 / (1 - ratio);\n    } else {\n      ratio = 1 + ratio;\n    }\n    this.zoomTo(imageData.width * ratio / imageData.naturalWidth, showTooltip, pivot, _originalEvent);\n    return this;\n  },\n  /**\n   * Zoom the image to an absolute ratio.\n   * @param {number} ratio - The target ratio.\n   * @param {boolean} [showTooltip] - Indicates whether to show the tooltip.\n   * @param {Object} [pivot] - The pivot point coordinate for zooming.\n   * @param {Event} [_originalEvent=null] - The original event if any.\n   * @param {Event} [_zoomable=false] - Indicates if the current zoom is available or not.\n   * @returns {Viewer} this\n   */\n  zoomTo: function zoomTo(ratio) {\n    var _this6 = this;\n    var showTooltip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var pivot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var _originalEvent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var _zoomable = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    var element = this.element,\n      options = this.options,\n      pointers = this.pointers,\n      imageData = this.imageData;\n    var x = imageData.x,\n      y = imageData.y,\n      width = imageData.width,\n      height = imageData.height,\n      naturalWidth = imageData.naturalWidth,\n      naturalHeight = imageData.naturalHeight;\n    ratio = Math.max(0, ratio);\n    if (isNumber(ratio) && this.viewed && !this.played && (_zoomable || options.zoomable)) {\n      if (!_zoomable) {\n        var minZoomRatio = Math.max(0.01, options.minZoomRatio);\n        var maxZoomRatio = Math.min(100, options.maxZoomRatio);\n        ratio = Math.min(Math.max(ratio, minZoomRatio), maxZoomRatio);\n      }\n      if (_originalEvent) {\n        switch (_originalEvent.type) {\n          case 'wheel':\n            if (options.zoomRatio >= 0.055 && ratio > 0.95 && ratio < 1.05) {\n              ratio = 1;\n            }\n            break;\n          case 'pointermove':\n          case 'touchmove':\n          case 'mousemove':\n            if (ratio > 0.99 && ratio < 1.01) {\n              ratio = 1;\n            }\n            break;\n        }\n      }\n      var newWidth = naturalWidth * ratio;\n      var newHeight = naturalHeight * ratio;\n      var offsetWidth = newWidth - width;\n      var offsetHeight = newHeight - height;\n      var oldRatio = imageData.ratio;\n      if (isFunction(options.zoom)) {\n        addListener(element, EVENT_ZOOM, options.zoom, {\n          once: true\n        });\n      }\n      if (dispatchEvent(element, EVENT_ZOOM, {\n        ratio: ratio,\n        oldRatio: oldRatio,\n        originalEvent: _originalEvent\n      }) === false) {\n        return this;\n      }\n      this.zooming = true;\n      if (_originalEvent) {\n        var offset = getOffset(this.viewer);\n        var center = pointers && Object.keys(pointers).length > 0 ? getPointersCenter(pointers) : {\n          pageX: _originalEvent.pageX,\n          pageY: _originalEvent.pageY\n        };\n\n        // Zoom from the triggering point of the event\n        imageData.x -= offsetWidth * ((center.pageX - offset.left - x) / width);\n        imageData.y -= offsetHeight * ((center.pageY - offset.top - y) / height);\n      } else if (isPlainObject(pivot) && isNumber(pivot.x) && isNumber(pivot.y)) {\n        imageData.x -= offsetWidth * ((pivot.x - x) / width);\n        imageData.y -= offsetHeight * ((pivot.y - y) / height);\n      } else {\n        // Zoom from the center of the image\n        imageData.x -= offsetWidth / 2;\n        imageData.y -= offsetHeight / 2;\n      }\n      imageData.left = imageData.x;\n      imageData.top = imageData.y;\n      imageData.width = newWidth;\n      imageData.height = newHeight;\n      imageData.oldRatio = oldRatio;\n      imageData.ratio = ratio;\n      this.renderImage(function () {\n        _this6.zooming = false;\n        if (isFunction(options.zoomed)) {\n          addListener(element, EVENT_ZOOMED, options.zoomed, {\n            once: true\n          });\n        }\n        dispatchEvent(element, EVENT_ZOOMED, {\n          ratio: ratio,\n          oldRatio: oldRatio,\n          originalEvent: _originalEvent\n        }, {\n          cancelable: false\n        });\n      });\n      if (showTooltip) {\n        this.tooltip();\n      }\n    }\n    return this;\n  },\n  /**\n   * Play the images\n   * @param {boolean|FullscreenOptions} [fullscreen=false] - Indicate if request fullscreen or not.\n   * @returns {Viewer} this\n   */\n  play: function play() {\n    var _this7 = this;\n    var fullscreen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (!this.isShown || this.played) {\n      return this;\n    }\n    var element = this.element,\n      options = this.options;\n    if (isFunction(options.play)) {\n      addListener(element, EVENT_PLAY, options.play, {\n        once: true\n      });\n    }\n    if (dispatchEvent(element, EVENT_PLAY) === false) {\n      return this;\n    }\n    var player = this.player;\n    var onLoad = this.loadImage.bind(this);\n    var list = [];\n    var total = 0;\n    var index = 0;\n    this.played = true;\n    this.onLoadWhenPlay = onLoad;\n    if (fullscreen) {\n      this.requestFullscreen(fullscreen);\n    }\n    addClass(player, CLASS_SHOW);\n    forEach(this.items, function (item, i) {\n      var img = item.querySelector('img');\n      var image = document.createElement('img');\n      image.src = getData(img, 'originalUrl');\n      image.alt = img.getAttribute('alt');\n      image.referrerPolicy = img.referrerPolicy;\n      total += 1;\n      addClass(image, CLASS_FADE);\n      toggleClass(image, CLASS_TRANSITION, options.transition);\n      if (hasClass(item, CLASS_ACTIVE)) {\n        addClass(image, CLASS_IN);\n        index = i;\n      }\n      list.push(image);\n      addListener(image, EVENT_LOAD, onLoad, {\n        once: true\n      });\n      player.appendChild(image);\n    });\n    if (isNumber(options.interval) && options.interval > 0) {\n      var prev = function prev() {\n        clearTimeout(_this7.playing.timeout);\n        removeClass(list[index], CLASS_IN);\n        index -= 1;\n        index = index >= 0 ? index : total - 1;\n        addClass(list[index], CLASS_IN);\n        _this7.playing.timeout = setTimeout(prev, options.interval);\n      };\n      var next = function next() {\n        clearTimeout(_this7.playing.timeout);\n        removeClass(list[index], CLASS_IN);\n        index += 1;\n        index = index < total ? index : 0;\n        addClass(list[index], CLASS_IN);\n        _this7.playing.timeout = setTimeout(next, options.interval);\n      };\n      if (total > 1) {\n        this.playing = {\n          prev: prev,\n          next: next,\n          timeout: setTimeout(next, options.interval)\n        };\n      }\n    }\n    return this;\n  },\n  // Stop play\n  stop: function stop() {\n    var _this8 = this;\n    if (!this.played) {\n      return this;\n    }\n    var element = this.element,\n      options = this.options;\n    if (isFunction(options.stop)) {\n      addListener(element, EVENT_STOP, options.stop, {\n        once: true\n      });\n    }\n    if (dispatchEvent(element, EVENT_STOP) === false) {\n      return this;\n    }\n    var player = this.player;\n    clearTimeout(this.playing.timeout);\n    this.playing = false;\n    this.played = false;\n    forEach(player.getElementsByTagName('img'), function (image) {\n      removeListener(image, EVENT_LOAD, _this8.onLoadWhenPlay);\n    });\n    removeClass(player, CLASS_SHOW);\n    player.innerHTML = '';\n    this.exitFullscreen();\n    return this;\n  },\n  // Enter modal mode (only available in inline mode)\n  full: function full() {\n    var _this9 = this;\n    var options = this.options,\n      viewer = this.viewer,\n      image = this.image,\n      list = this.list;\n    if (!this.isShown || this.played || this.fulled || !options.inline) {\n      return this;\n    }\n    this.fulled = true;\n    this.open();\n    addClass(this.button, CLASS_FULLSCREEN_EXIT);\n    if (options.transition) {\n      removeClass(list, CLASS_TRANSITION);\n      if (this.viewed) {\n        removeClass(image, CLASS_TRANSITION);\n      }\n    }\n    addClass(viewer, CLASS_FIXED);\n    viewer.setAttribute('role', 'dialog');\n    viewer.setAttribute('aria-labelledby', this.title.id);\n    viewer.setAttribute('aria-modal', true);\n    viewer.removeAttribute('style');\n    setStyle(viewer, {\n      zIndex: options.zIndex\n    });\n    if (options.focus) {\n      this.enforceFocus();\n    }\n    this.initContainer();\n    this.viewerData = assign({}, this.containerData);\n    this.renderList();\n    if (this.viewed) {\n      this.initImage(function () {\n        _this9.renderImage(function () {\n          if (options.transition) {\n            setTimeout(function () {\n              addClass(image, CLASS_TRANSITION);\n              addClass(list, CLASS_TRANSITION);\n            }, 0);\n          }\n        });\n      });\n    }\n    return this;\n  },\n  // Exit modal mode (only available in inline mode)\n  exit: function exit() {\n    var _this10 = this;\n    var options = this.options,\n      viewer = this.viewer,\n      image = this.image,\n      list = this.list;\n    if (!this.isShown || this.played || !this.fulled || !options.inline) {\n      return this;\n    }\n    this.fulled = false;\n    this.close();\n    removeClass(this.button, CLASS_FULLSCREEN_EXIT);\n    if (options.transition) {\n      removeClass(list, CLASS_TRANSITION);\n      if (this.viewed) {\n        removeClass(image, CLASS_TRANSITION);\n      }\n    }\n    if (options.focus) {\n      this.clearEnforceFocus();\n    }\n    viewer.removeAttribute('role');\n    viewer.removeAttribute('aria-labelledby');\n    viewer.removeAttribute('aria-modal');\n    removeClass(viewer, CLASS_FIXED);\n    setStyle(viewer, {\n      zIndex: options.zIndexInline\n    });\n    this.viewerData = assign({}, this.parentData);\n    this.renderViewer();\n    this.renderList();\n    if (this.viewed) {\n      this.initImage(function () {\n        _this10.renderImage(function () {\n          if (options.transition) {\n            setTimeout(function () {\n              addClass(image, CLASS_TRANSITION);\n              addClass(list, CLASS_TRANSITION);\n            }, 0);\n          }\n        });\n      });\n    }\n    return this;\n  },\n  // Show the current ratio of the image with percentage\n  tooltip: function tooltip() {\n    var _this11 = this;\n    var options = this.options,\n      tooltipBox = this.tooltipBox,\n      imageData = this.imageData;\n    if (!this.viewed || this.played || !options.tooltip) {\n      return this;\n    }\n    tooltipBox.textContent = \"\".concat(Math.round(imageData.ratio * 100), \"%\");\n    if (!this.tooltipping) {\n      if (options.transition) {\n        if (this.fading) {\n          dispatchEvent(tooltipBox, EVENT_TRANSITION_END);\n        }\n        addClass(tooltipBox, CLASS_SHOW);\n        addClass(tooltipBox, CLASS_FADE);\n        addClass(tooltipBox, CLASS_TRANSITION);\n        tooltipBox.removeAttribute('aria-hidden');\n\n        // Force reflow to enable CSS3 transition\n        tooltipBox.initialOffsetWidth = tooltipBox.offsetWidth;\n        addClass(tooltipBox, CLASS_IN);\n      } else {\n        addClass(tooltipBox, CLASS_SHOW);\n        tooltipBox.removeAttribute('aria-hidden');\n      }\n    } else {\n      clearTimeout(this.tooltipping);\n    }\n    this.tooltipping = setTimeout(function () {\n      if (options.transition) {\n        addListener(tooltipBox, EVENT_TRANSITION_END, function () {\n          removeClass(tooltipBox, CLASS_SHOW);\n          removeClass(tooltipBox, CLASS_FADE);\n          removeClass(tooltipBox, CLASS_TRANSITION);\n          tooltipBox.setAttribute('aria-hidden', true);\n          _this11.fading = false;\n        }, {\n          once: true\n        });\n        removeClass(tooltipBox, CLASS_IN);\n        _this11.fading = true;\n      } else {\n        removeClass(tooltipBox, CLASS_SHOW);\n        tooltipBox.setAttribute('aria-hidden', true);\n      }\n      _this11.tooltipping = false;\n    }, 1000);\n    return this;\n  },\n  /**\n   * Toggle the image size between its current size and natural size\n   * @param {Event} [_originalEvent=null] - The original event if any.\n   * @returns {Viewer} this\n   */\n  toggle: function toggle() {\n    var _originalEvent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    if (this.imageData.ratio === 1) {\n      this.zoomTo(this.imageData.oldRatio, true, null, _originalEvent);\n    } else {\n      this.zoomTo(1, true, null, _originalEvent);\n    }\n    return this;\n  },\n  // Reset the image to its initial state\n  reset: function reset() {\n    if (this.viewed && !this.played) {\n      this.imageData = assign({}, this.initialImageData);\n      this.renderImage();\n    }\n    return this;\n  },\n  // Update viewer when images changed\n  update: function update() {\n    var _this12 = this;\n    var element = this.element,\n      options = this.options,\n      isImg = this.isImg;\n\n    // Destroy viewer if the target image was deleted\n    if (isImg && !element.parentNode) {\n      return this.destroy();\n    }\n    var images = [];\n    forEach(isImg ? [element] : element.querySelectorAll('img'), function (image) {\n      if (isFunction(options.filter)) {\n        if (options.filter.call(_this12, image)) {\n          images.push(image);\n        }\n      } else if (_this12.getImageURL(image)) {\n        images.push(image);\n      }\n    });\n    if (!images.length) {\n      return this;\n    }\n    this.images = images;\n    this.length = images.length;\n    if (this.ready) {\n      var changedIndexes = [];\n      forEach(this.items, function (item, i) {\n        var img = item.querySelector('img');\n        var image = images[i];\n        if (image && img) {\n          if (image.src !== img.src\n\n          // Title changed (#408)\n          || image.alt !== img.alt) {\n            changedIndexes.push(i);\n          }\n        } else {\n          changedIndexes.push(i);\n        }\n      });\n      setStyle(this.list, {\n        width: 'auto'\n      });\n      this.initList();\n      if (this.isShown) {\n        if (this.length) {\n          if (this.viewed) {\n            var changedIndex = changedIndexes.indexOf(this.index);\n            if (changedIndex >= 0) {\n              this.viewed = false;\n              this.view(Math.max(Math.min(this.index - changedIndex, this.length - 1), 0));\n            } else {\n              var activeItem = this.items[this.index];\n\n              // Reactivate the current viewing item after reset the list.\n              addClass(activeItem, CLASS_ACTIVE);\n              activeItem.setAttribute('aria-selected', true);\n            }\n          }\n        } else {\n          this.image = null;\n          this.viewed = false;\n          this.index = 0;\n          this.imageData = {};\n          this.canvas.innerHTML = '';\n          this.title.innerHTML = '';\n        }\n      }\n    } else {\n      this.build();\n    }\n    return this;\n  },\n  // Destroy the viewer\n  destroy: function destroy() {\n    var element = this.element,\n      options = this.options;\n    if (!element[NAMESPACE]) {\n      return this;\n    }\n    this.destroyed = true;\n    if (this.ready) {\n      if (this.played) {\n        this.stop();\n      }\n      if (options.inline) {\n        if (this.fulled) {\n          this.exit();\n        }\n        this.unbind();\n      } else if (this.isShown) {\n        if (this.viewing) {\n          if (this.imageRendering) {\n            this.imageRendering.abort();\n          } else if (this.imageInitializing) {\n            this.imageInitializing.abort();\n          }\n        }\n        if (this.hiding) {\n          this.transitioning.abort();\n        }\n        this.hidden();\n      } else if (this.showing) {\n        this.transitioning.abort();\n        this.hidden();\n      }\n      this.ready = false;\n      this.viewer.parentNode.removeChild(this.viewer);\n    } else if (options.inline) {\n      if (this.delaying) {\n        this.delaying.abort();\n      } else if (this.initializing) {\n        this.initializing.abort();\n      }\n    }\n    if (!options.inline) {\n      removeListener(element, EVENT_CLICK, this.onStart);\n    }\n    element[NAMESPACE] = undefined;\n    return this;\n  }\n};\n\nvar others = {\n  getImageURL: function getImageURL(image) {\n    var url = this.options.url;\n    if (isString(url)) {\n      url = image.getAttribute(url);\n    } else if (isFunction(url)) {\n      url = url.call(this, image);\n    } else {\n      url = '';\n    }\n    return url;\n  },\n  enforceFocus: function enforceFocus() {\n    var _this = this;\n    this.clearEnforceFocus();\n    addListener(document, EVENT_FOCUSIN, this.onFocusin = function (event) {\n      var viewer = _this.viewer;\n      var target = event.target;\n      if (target === document || target === viewer || viewer.contains(target)) {\n        return;\n      }\n      while (target) {\n        // Avoid conflicts with other modals (#474, #540)\n        if (target.getAttribute('tabindex') !== null || target.getAttribute('aria-modal') === 'true') {\n          return;\n        }\n        target = target.parentElement;\n      }\n      viewer.focus();\n    });\n  },\n  clearEnforceFocus: function clearEnforceFocus() {\n    if (this.onFocusin) {\n      removeListener(document, EVENT_FOCUSIN, this.onFocusin);\n      this.onFocusin = null;\n    }\n  },\n  open: function open() {\n    var body = this.body;\n    addClass(body, CLASS_OPEN);\n    if (this.scrollbarWidth > 0) {\n      body.style.paddingRight = \"\".concat(this.scrollbarWidth + (parseFloat(this.initialBodyComputedPaddingRight) || 0), \"px\");\n    }\n  },\n  close: function close() {\n    var body = this.body;\n    removeClass(body, CLASS_OPEN);\n    if (this.scrollbarWidth > 0) {\n      body.style.paddingRight = this.initialBodyPaddingRight;\n    }\n  },\n  shown: function shown() {\n    var element = this.element,\n      options = this.options,\n      viewer = this.viewer;\n    this.fulled = true;\n    this.isShown = true;\n    this.render();\n    this.bind();\n    this.showing = false;\n    if (options.focus) {\n      viewer.focus();\n      this.enforceFocus();\n    }\n    if (isFunction(options.shown)) {\n      addListener(element, EVENT_SHOWN, options.shown, {\n        once: true\n      });\n    }\n    if (dispatchEvent(element, EVENT_SHOWN) === false) {\n      return;\n    }\n    if (this.ready && this.isShown && !this.hiding) {\n      this.view(this.index);\n    }\n  },\n  hidden: function hidden() {\n    var element = this.element,\n      options = this.options,\n      viewer = this.viewer;\n    if (options.fucus) {\n      this.clearEnforceFocus();\n    }\n    this.close();\n    this.unbind();\n    addClass(viewer, CLASS_HIDE);\n    viewer.removeAttribute('role');\n    viewer.removeAttribute('aria-labelledby');\n    viewer.removeAttribute('aria-modal');\n    viewer.setAttribute('aria-hidden', true);\n    this.resetList();\n    this.resetImage();\n    this.fulled = false;\n    this.viewed = false;\n    this.isShown = false;\n    this.hiding = false;\n    if (!this.destroyed) {\n      if (isFunction(options.hidden)) {\n        addListener(element, EVENT_HIDDEN, options.hidden, {\n          once: true\n        });\n      }\n      dispatchEvent(element, EVENT_HIDDEN, null, {\n        cancelable: false\n      });\n    }\n  },\n  requestFullscreen: function requestFullscreen(options) {\n    var document = this.element.ownerDocument;\n    if (this.fulled && !(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {\n      var documentElement = document.documentElement;\n\n      // Element.requestFullscreen()\n      if (documentElement.requestFullscreen) {\n        // Avoid TypeError when convert `options` to dictionary\n        if (isPlainObject(options)) {\n          documentElement.requestFullscreen(options);\n        } else {\n          documentElement.requestFullscreen();\n        }\n      } else if (documentElement.webkitRequestFullscreen) {\n        documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);\n      } else if (documentElement.mozRequestFullScreen) {\n        documentElement.mozRequestFullScreen();\n      } else if (documentElement.msRequestFullscreen) {\n        documentElement.msRequestFullscreen();\n      }\n    }\n  },\n  exitFullscreen: function exitFullscreen() {\n    var document = this.element.ownerDocument;\n    if (this.fulled && (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {\n      // Document.exitFullscreen()\n      if (document.exitFullscreen) {\n        document.exitFullscreen();\n      } else if (document.webkitExitFullscreen) {\n        document.webkitExitFullscreen();\n      } else if (document.mozCancelFullScreen) {\n        document.mozCancelFullScreen();\n      } else if (document.msExitFullscreen) {\n        document.msExitFullscreen();\n      }\n    }\n  },\n  change: function change(event) {\n    var options = this.options,\n      pointers = this.pointers;\n    var pointer = pointers[Object.keys(pointers)[0]];\n\n    // In the case of the `pointers` object is empty (#421)\n    if (!pointer) {\n      return;\n    }\n    var offsetX = pointer.endX - pointer.startX;\n    var offsetY = pointer.endY - pointer.startY;\n    switch (this.action) {\n      // Move the current image\n      case ACTION_MOVE:\n        if (offsetX !== 0 || offsetY !== 0) {\n          this.pointerMoved = true;\n          this.move(offsetX, offsetY, event);\n        }\n        break;\n\n      // Zoom the current image\n      case ACTION_ZOOM:\n        this.zoom(getMaxZoomRatio(pointers), false, null, event);\n        break;\n      case ACTION_SWITCH:\n        {\n          this.action = 'switched';\n          var absoluteOffsetX = Math.abs(offsetX);\n          if (absoluteOffsetX > 1 && absoluteOffsetX > Math.abs(offsetY)) {\n            // Empty `pointers` as `touchend` event will not be fired after swiped in iOS browsers.\n            this.pointers = {};\n            if (offsetX > 1) {\n              this.prev(options.loop);\n            } else if (offsetX < -1) {\n              this.next(options.loop);\n            }\n          }\n          break;\n        }\n    }\n\n    // Override\n    forEach(pointers, function (p) {\n      p.startX = p.endX;\n      p.startY = p.endY;\n    });\n  },\n  isSwitchable: function isSwitchable() {\n    var imageData = this.imageData,\n      viewerData = this.viewerData;\n    return this.length > 1 && imageData.x >= 0 && imageData.y >= 0 && imageData.width <= viewerData.width && imageData.height <= viewerData.height;\n  }\n};\n\nvar AnotherViewer = WINDOW.Viewer;\nvar getUniqueID = function (id) {\n  return function () {\n    id += 1;\n    return id;\n  };\n}(-1);\nvar Viewer = /*#__PURE__*/function () {\n  /**\n   * Create a new Viewer.\n   * @param {Element} element - The target element for viewing.\n   * @param {Object} [options={}] - The configuration options.\n   */\n  function Viewer(element) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, Viewer);\n    if (!element || element.nodeType !== 1) {\n      throw new Error('The first argument is required and must be an element.');\n    }\n    this.element = element;\n    this.options = assign({}, DEFAULTS, isPlainObject(options) && options);\n    this.action = false;\n    this.fading = false;\n    this.fulled = false;\n    this.hiding = false;\n    this.imageClicked = false;\n    this.imageData = {};\n    this.index = this.options.initialViewIndex;\n    this.isImg = false;\n    this.isShown = false;\n    this.length = 0;\n    this.moving = false;\n    this.played = false;\n    this.playing = false;\n    this.pointers = {};\n    this.ready = false;\n    this.rotating = false;\n    this.scaling = false;\n    this.showing = false;\n    this.timeout = false;\n    this.tooltipping = false;\n    this.viewed = false;\n    this.viewing = false;\n    this.wheeling = false;\n    this.zooming = false;\n    this.pointerMoved = false;\n    this.id = getUniqueID();\n    this.init();\n  }\n  _createClass(Viewer, [{\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n      var element = this.element,\n        options = this.options;\n      if (element[NAMESPACE]) {\n        return;\n      }\n      element[NAMESPACE] = this;\n\n      // The `focus` option requires the `keyboard` option set to `true`.\n      if (options.focus && !options.keyboard) {\n        options.focus = false;\n      }\n      var isImg = element.localName === 'img';\n      var images = [];\n      forEach(isImg ? [element] : element.querySelectorAll('img'), function (image) {\n        if (isFunction(options.filter)) {\n          if (options.filter.call(_this, image)) {\n            images.push(image);\n          }\n        } else if (_this.getImageURL(image)) {\n          images.push(image);\n        }\n      });\n      this.isImg = isImg;\n      this.length = images.length;\n      this.images = images;\n      this.initBody();\n\n      // Override `transition` option if it is not supported\n      if (isUndefined(document.createElement(NAMESPACE).style.transition)) {\n        options.transition = false;\n      }\n      if (options.inline) {\n        var count = 0;\n        var progress = function progress() {\n          count += 1;\n          if (count === _this.length) {\n            var timeout;\n            _this.initializing = false;\n            _this.delaying = {\n              abort: function abort() {\n                clearTimeout(timeout);\n              }\n            };\n\n            // build asynchronously to keep `this.viewer` is accessible in `ready` event handler.\n            timeout = setTimeout(function () {\n              _this.delaying = false;\n              _this.build();\n            }, 0);\n          }\n        };\n        this.initializing = {\n          abort: function abort() {\n            forEach(images, function (image) {\n              if (!image.complete) {\n                removeListener(image, EVENT_LOAD, progress);\n                removeListener(image, EVENT_ERROR, progress);\n              }\n            });\n          }\n        };\n        forEach(images, function (image) {\n          if (image.complete) {\n            progress();\n          } else {\n            var onLoad;\n            var onError;\n            addListener(image, EVENT_LOAD, onLoad = function onLoad() {\n              removeListener(image, EVENT_ERROR, onError);\n              progress();\n            }, {\n              once: true\n            });\n            addListener(image, EVENT_ERROR, onError = function onError() {\n              removeListener(image, EVENT_LOAD, onLoad);\n              progress();\n            }, {\n              once: true\n            });\n          }\n        });\n      } else {\n        addListener(element, EVENT_CLICK, this.onStart = function (_ref) {\n          var target = _ref.target;\n          if (target.localName === 'img' && (!isFunction(options.filter) || options.filter.call(_this, target))) {\n            _this.view(_this.images.indexOf(target));\n          }\n        });\n      }\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      if (this.ready) {\n        return;\n      }\n      var element = this.element,\n        options = this.options;\n      var parent = element.parentNode;\n      var template = document.createElement('div');\n      template.innerHTML = TEMPLATE;\n      var viewer = template.querySelector(\".\".concat(NAMESPACE, \"-container\"));\n      var title = viewer.querySelector(\".\".concat(NAMESPACE, \"-title\"));\n      var toolbar = viewer.querySelector(\".\".concat(NAMESPACE, \"-toolbar\"));\n      var navbar = viewer.querySelector(\".\".concat(NAMESPACE, \"-navbar\"));\n      var button = viewer.querySelector(\".\".concat(NAMESPACE, \"-button\"));\n      var canvas = viewer.querySelector(\".\".concat(NAMESPACE, \"-canvas\"));\n      this.parent = parent;\n      this.viewer = viewer;\n      this.title = title;\n      this.toolbar = toolbar;\n      this.navbar = navbar;\n      this.button = button;\n      this.canvas = canvas;\n      this.footer = viewer.querySelector(\".\".concat(NAMESPACE, \"-footer\"));\n      this.tooltipBox = viewer.querySelector(\".\".concat(NAMESPACE, \"-tooltip\"));\n      this.player = viewer.querySelector(\".\".concat(NAMESPACE, \"-player\"));\n      this.list = viewer.querySelector(\".\".concat(NAMESPACE, \"-list\"));\n      viewer.id = \"\".concat(NAMESPACE).concat(this.id);\n      title.id = \"\".concat(NAMESPACE, \"Title\").concat(this.id);\n      addClass(title, !options.title ? CLASS_HIDE : getResponsiveClass(Array.isArray(options.title) ? options.title[0] : options.title));\n      addClass(navbar, !options.navbar ? CLASS_HIDE : getResponsiveClass(options.navbar));\n      toggleClass(button, CLASS_HIDE, !options.button);\n      if (options.keyboard) {\n        button.setAttribute('tabindex', 0);\n      }\n      if (options.backdrop) {\n        addClass(viewer, \"\".concat(NAMESPACE, \"-backdrop\"));\n        if (!options.inline && options.backdrop !== 'static') {\n          setData(canvas, DATA_ACTION, 'hide');\n        }\n      }\n      if (isString(options.className) && options.className) {\n        // In case there are multiple class names\n        options.className.split(REGEXP_SPACES).forEach(function (className) {\n          addClass(viewer, className);\n        });\n      }\n      if (options.toolbar) {\n        var list = document.createElement('ul');\n        var custom = isPlainObject(options.toolbar);\n        var zoomButtons = BUTTONS.slice(0, 3);\n        var rotateButtons = BUTTONS.slice(7, 9);\n        var scaleButtons = BUTTONS.slice(9);\n        if (!custom) {\n          addClass(toolbar, getResponsiveClass(options.toolbar));\n        }\n        forEach(custom ? options.toolbar : BUTTONS, function (value, index) {\n          var deep = custom && isPlainObject(value);\n          var name = custom ? hyphenate(index) : value;\n          var show = deep && !isUndefined(value.show) ? value.show : value;\n          if (!show || !options.zoomable && zoomButtons.indexOf(name) !== -1 || !options.rotatable && rotateButtons.indexOf(name) !== -1 || !options.scalable && scaleButtons.indexOf(name) !== -1) {\n            return;\n          }\n          var size = deep && !isUndefined(value.size) ? value.size : value;\n          var click = deep && !isUndefined(value.click) ? value.click : value;\n          var item = document.createElement('li');\n          if (options.keyboard) {\n            item.setAttribute('tabindex', 0);\n          }\n          item.setAttribute('role', 'button');\n          addClass(item, \"\".concat(NAMESPACE, \"-\").concat(name));\n          if (!isFunction(click)) {\n            setData(item, DATA_ACTION, name);\n          }\n          if (isNumber(show)) {\n            addClass(item, getResponsiveClass(show));\n          }\n          if (['small', 'large'].indexOf(size) !== -1) {\n            addClass(item, \"\".concat(NAMESPACE, \"-\").concat(size));\n          } else if (name === 'play') {\n            addClass(item, \"\".concat(NAMESPACE, \"-large\"));\n          }\n          if (isFunction(click)) {\n            addListener(item, EVENT_CLICK, click);\n          }\n          list.appendChild(item);\n        });\n        toolbar.appendChild(list);\n      } else {\n        addClass(toolbar, CLASS_HIDE);\n      }\n      if (!options.rotatable) {\n        var rotates = toolbar.querySelectorAll('li[class*=\"rotate\"]');\n        addClass(rotates, CLASS_INVISIBLE);\n        forEach(rotates, function (rotate) {\n          toolbar.appendChild(rotate);\n        });\n      }\n      if (options.inline) {\n        addClass(button, CLASS_FULLSCREEN);\n        setStyle(viewer, {\n          zIndex: options.zIndexInline\n        });\n        if (window.getComputedStyle(parent).position === 'static') {\n          setStyle(parent, {\n            position: 'relative'\n          });\n        }\n        parent.insertBefore(viewer, element.nextSibling);\n      } else {\n        addClass(button, CLASS_CLOSE);\n        addClass(viewer, CLASS_FIXED);\n        addClass(viewer, CLASS_FADE);\n        addClass(viewer, CLASS_HIDE);\n        setStyle(viewer, {\n          zIndex: options.zIndex\n        });\n        var container = options.container;\n        if (isString(container)) {\n          container = element.ownerDocument.querySelector(container);\n        }\n        if (!container) {\n          container = this.body;\n        }\n        container.appendChild(viewer);\n      }\n      if (options.inline) {\n        this.render();\n        this.bind();\n        this.isShown = true;\n      }\n      this.ready = true;\n      if (isFunction(options.ready)) {\n        addListener(element, EVENT_READY, options.ready, {\n          once: true\n        });\n      }\n      if (dispatchEvent(element, EVENT_READY) === false) {\n        this.ready = false;\n        return;\n      }\n      if (this.ready && options.inline) {\n        this.view(this.index);\n      }\n    }\n\n    /**\n     * Get the no conflict viewer class.\n     * @returns {Viewer} The viewer class.\n     */\n  }], [{\n    key: \"noConflict\",\n    value: function noConflict() {\n      window.Viewer = AnotherViewer;\n      return Viewer;\n    }\n\n    /**\n     * Change the default options.\n     * @param {Object} options - The new default options.\n     */\n  }, {\n    key: \"setDefaults\",\n    value: function setDefaults(options) {\n      assign(DEFAULTS, isPlainObject(options) && options);\n    }\n  }]);\n  return Viewer;\n}();\nassign(Viewer.prototype, render, events, handlers, methods, others);\n\nmodule.exports = Viewer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlld2VyanMvZGlzdC92aWV3ZXIuY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsMkJBQTJCO0FBQ3hDLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsUUFBUSxXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sb2dvc3BlcnVfbmV4dGpzLy4vbm9kZV9tb2R1bGVzL3ZpZXdlcmpzL2Rpc3Qvdmlld2VyLmNvbW1vbi5qcz9iNTVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVmlld2VyLmpzIHYxLjExLjZcbiAqIGh0dHBzOi8vZmVuZ3l1YW5jaGVuLmdpdGh1Yi5pby92aWV3ZXJqc1xuICpcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQgQ2hlbiBGZW5neXVhblxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKlxuICogRGF0ZTogMjAyMy0wOS0xN1QwMzoxNjozOC4wNTJaXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcbiAgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuICBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykge1xuICAgIHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcbiAgICByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgX3R5cGVvZihvKTtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpO1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDtcbiAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xufVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn1cblxudmFyIERFRkFVTFRTID0ge1xuICAvKipcbiAgICogRW5hYmxlIGEgbW9kYWwgYmFja2Ryb3AsIHNwZWNpZnkgYHN0YXRpY2AgZm9yIGEgYmFja2Ryb3BcbiAgICogd2hpY2ggZG9lc24ndCBjbG9zZSB0aGUgbW9kYWwgb24gY2xpY2suXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgYmFja2Ryb3A6IHRydWUsXG4gIC8qKlxuICAgKiBTaG93IHRoZSBidXR0b24gb24gdGhlIHRvcC1yaWdodCBvZiB0aGUgdmlld2VyLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGJ1dHRvbjogdHJ1ZSxcbiAgLyoqXG4gICAqIFNob3cgdGhlIG5hdmJhci5cbiAgICogQHR5cGUge2Jvb2xlYW4gfCBudW1iZXJ9XG4gICAqL1xuICBuYXZiYXI6IHRydWUsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSB2aXNpYmlsaXR5IGFuZCB0aGUgY29udGVudCBvZiB0aGUgdGl0bGUuXG4gICAqIEB0eXBlIHtib29sZWFuIHwgbnVtYmVyIHwgRnVuY3Rpb24gfCBBcnJheX1cbiAgICovXG4gIHRpdGxlOiB0cnVlLFxuICAvKipcbiAgICogU2hvdyB0aGUgdG9vbGJhci5cbiAgICogQHR5cGUge2Jvb2xlYW4gfCBudW1iZXIgfCBPYmplY3R9XG4gICAqL1xuICB0b29sYmFyOiB0cnVlLFxuICAvKipcbiAgICogQ3VzdG9tIGNsYXNzIG5hbWUocykgdG8gYWRkIHRvIHRoZSB2aWV3ZXIncyByb290IGVsZW1lbnQuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBjbGFzc05hbWU6ICcnLFxuICAvKipcbiAgICogRGVmaW5lIHdoZXJlIHRvIHB1dCB0aGUgdmlld2VyIGluIG1vZGFsIG1vZGUuXG4gICAqIEB0eXBlIHtzdHJpbmcgfCBFbGVtZW50fVxuICAgKi9cbiAgY29udGFpbmVyOiAnYm9keScsXG4gIC8qKlxuICAgKiBGaWx0ZXIgdGhlIGltYWdlcyBmb3Igdmlld2luZy4gUmV0dXJuIHRydWUgaWYgdGhlIGltYWdlIGlzIHZpZXdhYmxlLlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICBmaWx0ZXI6IG51bGwsXG4gIC8qKlxuICAgKiBFbmFibGUgdG8gcmVxdWVzdCBmdWxsc2NyZWVuIHdoZW4gcGxheS5cbiAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GdWxsc2NyZWVuT3B0aW9uc31cbiAgICogQHR5cGUge2Jvb2xlYW58RnVsbHNjcmVlbk9wdGlvbnN9XG4gICAqL1xuICBmdWxsc2NyZWVuOiB0cnVlLFxuICAvKipcbiAgICogRGVmaW5lIHRoZSBleHRyYSBhdHRyaWJ1dGVzIHRvIGluaGVyaXQgZnJvbSB0aGUgb3JpZ2luYWwgaW1hZ2UuXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICovXG4gIGluaGVyaXRlZEF0dHJpYnV0ZXM6IFsnY3Jvc3NPcmlnaW4nLCAnZGVjb2RpbmcnLCAnaXNNYXAnLCAnbG9hZGluZycsICdyZWZlcnJlclBvbGljeScsICdzaXplcycsICdzcmNzZXQnLCAndXNlTWFwJ10sXG4gIC8qKlxuICAgKiBEZWZpbmUgdGhlIGluaXRpYWwgY292ZXJhZ2Ugb2YgdGhlIHZpZXdpbmcgaW1hZ2UuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBpbml0aWFsQ292ZXJhZ2U6IDAuOSxcbiAgLyoqXG4gICAqIERlZmluZSB0aGUgaW5pdGlhbCBpbmRleCBvZiB0aGUgaW1hZ2UgZm9yIHZpZXdpbmcuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBpbml0aWFsVmlld0luZGV4OiAwLFxuICAvKipcbiAgICogRW5hYmxlIGlubGluZSBtb2RlLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGlubGluZTogZmFsc2UsXG4gIC8qKlxuICAgKiBUaGUgYW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgYmV0d2VlbiBhdXRvbWF0aWNhbGx5IGN5Y2xpbmcgYW4gaW1hZ2Ugd2hlbiBwbGF5aW5nLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgaW50ZXJ2YWw6IDUwMDAsXG4gIC8qKlxuICAgKiBFbmFibGUga2V5Ym9hcmQgc3VwcG9ydC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBrZXlib2FyZDogdHJ1ZSxcbiAgLyoqXG4gICAqIEZvY3VzIHRoZSB2aWV3ZXIgd2hlbiBpbml0aWFsaXplZC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBmb2N1czogdHJ1ZSxcbiAgLyoqXG4gICAqIEluZGljYXRlIGlmIHNob3cgYSBsb2FkaW5nIHNwaW5uZXIgd2hlbiBsb2FkIGltYWdlIG9yIG5vdC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBsb2FkaW5nOiB0cnVlLFxuICAvKipcbiAgICogSW5kaWNhdGUgaWYgZW5hYmxlIGxvb3Agdmlld2luZyBvciBub3QuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgbG9vcDogdHJ1ZSxcbiAgLyoqXG4gICAqIE1pbiB3aWR0aCBvZiB0aGUgdmlld2VyIGluIGlubGluZSBtb2RlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgbWluV2lkdGg6IDIwMCxcbiAgLyoqXG4gICAqIE1pbiBoZWlnaHQgb2YgdGhlIHZpZXdlciBpbiBpbmxpbmUgbW9kZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIG1pbkhlaWdodDogMTAwLFxuICAvKipcbiAgICogRW5hYmxlIHRvIG1vdmUgdGhlIGltYWdlLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIG1vdmFibGU6IHRydWUsXG4gIC8qKlxuICAgKiBFbmFibGUgdG8gcm90YXRlIHRoZSBpbWFnZS5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICByb3RhdGFibGU6IHRydWUsXG4gIC8qKlxuICAgKiBFbmFibGUgdG8gc2NhbGUgdGhlIGltYWdlLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHNjYWxhYmxlOiB0cnVlLFxuICAvKipcbiAgICogRW5hYmxlIHRvIHpvb20gdGhlIGltYWdlLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHpvb21hYmxlOiB0cnVlLFxuICAvKipcbiAgICogRW5hYmxlIHRvIHpvb20gdGhlIGN1cnJlbnQgaW1hZ2UgYnkgZHJhZ2dpbmcgb24gdGhlIHRvdWNoIHNjcmVlbi5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB6b29tT25Ub3VjaDogdHJ1ZSxcbiAgLyoqXG4gICAqIEVuYWJsZSB0byB6b29tIHRoZSBpbWFnZSBieSB3aGVlbGluZyBtb3VzZS5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB6b29tT25XaGVlbDogdHJ1ZSxcbiAgLyoqXG4gICAqIEVuYWJsZSB0byBzbGlkZSB0byB0aGUgbmV4dCBvciBwcmV2aW91cyBpbWFnZSBieSBzd2lwaW5nIG9uIHRoZSB0b3VjaCBzY3JlZW4uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgc2xpZGVPblRvdWNoOiB0cnVlLFxuICAvKipcbiAgICogSW5kaWNhdGUgaWYgdG9nZ2xlIHRoZSBpbWFnZSBzaXplIGJldHdlZW4gaXRzIG5hdHVyYWwgc2l6ZVxuICAgKiBhbmQgaW5pdGlhbCBzaXplIHdoZW4gZG91YmxlIGNsaWNrIG9uIHRoZSBpbWFnZSBvciBub3QuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdG9nZ2xlT25EYmxjbGljazogdHJ1ZSxcbiAgLyoqXG4gICAqIFNob3cgdGhlIHRvb2x0aXAgd2l0aCBpbWFnZSByYXRpbyAocGVyY2VudGFnZSkgd2hlbiB6b29tIGluIG9yIHpvb20gb3V0LlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRvb2x0aXA6IHRydWUsXG4gIC8qKlxuICAgKiBFbmFibGUgQ1NTMyBUcmFuc2l0aW9uIGZvciBzb21lIHNwZWNpYWwgZWxlbWVudHMuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgLyoqXG4gICAqIERlZmluZSB0aGUgQ1NTIGB6LWluZGV4YCB2YWx1ZSBvZiB2aWV3ZXIgaW4gbW9kYWwgbW9kZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHpJbmRleDogMjAxNSxcbiAgLyoqXG4gICAqIERlZmluZSB0aGUgQ1NTIGB6LWluZGV4YCB2YWx1ZSBvZiB2aWV3ZXIgaW4gaW5saW5lIG1vZGUuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB6SW5kZXhJbmxpbmU6IDAsXG4gIC8qKlxuICAgKiBEZWZpbmUgdGhlIHJhdGlvIHdoZW4gem9vbSB0aGUgaW1hZ2UgYnkgd2hlZWxpbmcgbW91c2UuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB6b29tUmF0aW86IDAuMSxcbiAgLyoqXG4gICAqIERlZmluZSB0aGUgbWluIHJhdGlvIG9mIHRoZSBpbWFnZSB3aGVuIHpvb20gb3V0LlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgbWluWm9vbVJhdGlvOiAwLjAxLFxuICAvKipcbiAgICogRGVmaW5lIHRoZSBtYXggcmF0aW8gb2YgdGhlIGltYWdlIHdoZW4gem9vbSBpbi5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIG1heFpvb21SYXRpbzogMTAwLFxuICAvKipcbiAgICogRGVmaW5lIHdoZXJlIHRvIGdldCB0aGUgb3JpZ2luYWwgaW1hZ2UgVVJMIGZvciB2aWV3aW5nLlxuICAgKiBAdHlwZSB7c3RyaW5nIHwgRnVuY3Rpb259XG4gICAqL1xuICB1cmw6ICdzcmMnLFxuICAvKipcbiAgICogRXZlbnQgc2hvcnRjdXRzLlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICByZWFkeTogbnVsbCxcbiAgc2hvdzogbnVsbCxcbiAgc2hvd246IG51bGwsXG4gIGhpZGU6IG51bGwsXG4gIGhpZGRlbjogbnVsbCxcbiAgdmlldzogbnVsbCxcbiAgdmlld2VkOiBudWxsLFxuICBtb3ZlOiBudWxsLFxuICBtb3ZlZDogbnVsbCxcbiAgcm90YXRlOiBudWxsLFxuICByb3RhdGVkOiBudWxsLFxuICBzY2FsZTogbnVsbCxcbiAgc2NhbGVkOiBudWxsLFxuICB6b29tOiBudWxsLFxuICB6b29tZWQ6IG51bGwsXG4gIHBsYXk6IG51bGwsXG4gIHN0b3A6IG51bGxcbn07XG5cbnZhciBURU1QTEFURSA9ICc8ZGl2IGNsYXNzPVwidmlld2VyLWNvbnRhaW5lclwiIHRhYmluZGV4PVwiLTFcIiB0b3VjaC1hY3Rpb249XCJub25lXCI+JyArICc8ZGl2IGNsYXNzPVwidmlld2VyLWNhbnZhc1wiPjwvZGl2PicgKyAnPGRpdiBjbGFzcz1cInZpZXdlci1mb290ZXJcIj4nICsgJzxkaXYgY2xhc3M9XCJ2aWV3ZXItdGl0bGVcIj48L2Rpdj4nICsgJzxkaXYgY2xhc3M9XCJ2aWV3ZXItdG9vbGJhclwiPjwvZGl2PicgKyAnPGRpdiBjbGFzcz1cInZpZXdlci1uYXZiYXJcIj4nICsgJzx1bCBjbGFzcz1cInZpZXdlci1saXN0XCIgcm9sZT1cIm5hdmlnYXRpb25cIj48L3VsPicgKyAnPC9kaXY+JyArICc8L2Rpdj4nICsgJzxkaXYgY2xhc3M9XCJ2aWV3ZXItdG9vbHRpcFwiIHJvbGU9XCJhbGVydFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvZGl2PicgKyAnPGRpdiBjbGFzcz1cInZpZXdlci1idXR0b25cIiBkYXRhLXZpZXdlci1hY3Rpb249XCJtaXhcIiByb2xlPVwiYnV0dG9uXCI+PC9kaXY+JyArICc8ZGl2IGNsYXNzPVwidmlld2VyLXBsYXllclwiPjwvZGl2PicgKyAnPC9kaXY+JztcblxudmFyIElTX0JST1dTRVIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbnZhciBXSU5ET1cgPSBJU19CUk9XU0VSID8gd2luZG93IDoge307XG52YXIgSVNfVE9VQ0hfREVWSUNFID0gSVNfQlJPV1NFUiAmJiBXSU5ET1cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gJ29udG91Y2hzdGFydCcgaW4gV0lORE9XLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA6IGZhbHNlO1xudmFyIEhBU19QT0lOVEVSX0VWRU5UID0gSVNfQlJPV1NFUiA/ICdQb2ludGVyRXZlbnQnIGluIFdJTkRPVyA6IGZhbHNlO1xudmFyIE5BTUVTUEFDRSA9ICd2aWV3ZXInO1xuXG4vLyBBY3Rpb25zXG52YXIgQUNUSU9OX01PVkUgPSAnbW92ZSc7XG52YXIgQUNUSU9OX1NXSVRDSCA9ICdzd2l0Y2gnO1xudmFyIEFDVElPTl9aT09NID0gJ3pvb20nO1xuXG4vLyBDbGFzc2VzXG52YXIgQ0xBU1NfQUNUSVZFID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1hY3RpdmVcIik7XG52YXIgQ0xBU1NfQ0xPU0UgPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWNsb3NlXCIpO1xudmFyIENMQVNTX0ZBREUgPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWZhZGVcIik7XG52YXIgQ0xBU1NfRklYRUQgPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWZpeGVkXCIpO1xudmFyIENMQVNTX0ZVTExTQ1JFRU4gPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWZ1bGxzY3JlZW5cIik7XG52YXIgQ0xBU1NfRlVMTFNDUkVFTl9FWElUID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1mdWxsc2NyZWVuLWV4aXRcIik7XG52YXIgQ0xBU1NfSElERSA9IFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItaGlkZVwiKTtcbnZhciBDTEFTU19ISURFX01EX0RPV04gPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWhpZGUtbWQtZG93blwiKTtcbnZhciBDTEFTU19ISURFX1NNX0RPV04gPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWhpZGUtc20tZG93blwiKTtcbnZhciBDTEFTU19ISURFX1hTX0RPV04gPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWhpZGUteHMtZG93blwiKTtcbnZhciBDTEFTU19JTiA9IFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItaW5cIik7XG52YXIgQ0xBU1NfSU5WSVNJQkxFID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1pbnZpc2libGVcIik7XG52YXIgQ0xBU1NfTE9BRElORyA9IFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItbG9hZGluZ1wiKTtcbnZhciBDTEFTU19NT1ZFID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1tb3ZlXCIpO1xudmFyIENMQVNTX09QRU4gPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLW9wZW5cIik7XG52YXIgQ0xBU1NfU0hPVyA9IFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItc2hvd1wiKTtcbnZhciBDTEFTU19UUkFOU0lUSU9OID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi10cmFuc2l0aW9uXCIpO1xuXG4vLyBOYXRpdmUgZXZlbnRzXG52YXIgRVZFTlRfQ0xJQ0sgPSAnY2xpY2snO1xudmFyIEVWRU5UX0RCTENMSUNLID0gJ2RibGNsaWNrJztcbnZhciBFVkVOVF9EUkFHX1NUQVJUID0gJ2RyYWdzdGFydCc7XG52YXIgRVZFTlRfRk9DVVNJTiA9ICdmb2N1c2luJztcbnZhciBFVkVOVF9LRVlfRE9XTiA9ICdrZXlkb3duJztcbnZhciBFVkVOVF9MT0FEID0gJ2xvYWQnO1xudmFyIEVWRU5UX0VSUk9SID0gJ2Vycm9yJztcbnZhciBFVkVOVF9UT1VDSF9FTkQgPSBJU19UT1VDSF9ERVZJQ0UgPyAndG91Y2hlbmQgdG91Y2hjYW5jZWwnIDogJ21vdXNldXAnO1xudmFyIEVWRU5UX1RPVUNIX01PVkUgPSBJU19UT1VDSF9ERVZJQ0UgPyAndG91Y2htb3ZlJyA6ICdtb3VzZW1vdmUnO1xudmFyIEVWRU5UX1RPVUNIX1NUQVJUID0gSVNfVE9VQ0hfREVWSUNFID8gJ3RvdWNoc3RhcnQnIDogJ21vdXNlZG93bic7XG52YXIgRVZFTlRfUE9JTlRFUl9ET1dOID0gSEFTX1BPSU5URVJfRVZFTlQgPyAncG9pbnRlcmRvd24nIDogRVZFTlRfVE9VQ0hfU1RBUlQ7XG52YXIgRVZFTlRfUE9JTlRFUl9NT1ZFID0gSEFTX1BPSU5URVJfRVZFTlQgPyAncG9pbnRlcm1vdmUnIDogRVZFTlRfVE9VQ0hfTU9WRTtcbnZhciBFVkVOVF9QT0lOVEVSX1VQID0gSEFTX1BPSU5URVJfRVZFTlQgPyAncG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwnIDogRVZFTlRfVE9VQ0hfRU5EO1xudmFyIEVWRU5UX1JFU0laRSA9ICdyZXNpemUnO1xudmFyIEVWRU5UX1RSQU5TSVRJT05fRU5EID0gJ3RyYW5zaXRpb25lbmQnO1xudmFyIEVWRU5UX1dIRUVMID0gJ3doZWVsJztcblxuLy8gQ3VzdG9tIGV2ZW50c1xudmFyIEVWRU5UX1JFQURZID0gJ3JlYWR5JztcbnZhciBFVkVOVF9TSE9XID0gJ3Nob3cnO1xudmFyIEVWRU5UX1NIT1dOID0gJ3Nob3duJztcbnZhciBFVkVOVF9ISURFID0gJ2hpZGUnO1xudmFyIEVWRU5UX0hJRERFTiA9ICdoaWRkZW4nO1xudmFyIEVWRU5UX1ZJRVcgPSAndmlldyc7XG52YXIgRVZFTlRfVklFV0VEID0gJ3ZpZXdlZCc7XG52YXIgRVZFTlRfTU9WRSA9ICdtb3ZlJztcbnZhciBFVkVOVF9NT1ZFRCA9ICdtb3ZlZCc7XG52YXIgRVZFTlRfUk9UQVRFID0gJ3JvdGF0ZSc7XG52YXIgRVZFTlRfUk9UQVRFRCA9ICdyb3RhdGVkJztcbnZhciBFVkVOVF9TQ0FMRSA9ICdzY2FsZSc7XG52YXIgRVZFTlRfU0NBTEVEID0gJ3NjYWxlZCc7XG52YXIgRVZFTlRfWk9PTSA9ICd6b29tJztcbnZhciBFVkVOVF9aT09NRUQgPSAnem9vbWVkJztcbnZhciBFVkVOVF9QTEFZID0gJ3BsYXknO1xudmFyIEVWRU5UX1NUT1AgPSAnc3RvcCc7XG5cbi8vIERhdGEga2V5c1xudmFyIERBVEFfQUNUSU9OID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIkFjdGlvblwiKTtcblxuLy8gUmVnRXhwc1xudmFyIFJFR0VYUF9TUEFDRVMgPSAvXFxzXFxzKi87XG5cbi8vIE1pc2NcbnZhciBCVVRUT05TID0gWyd6b29tLWluJywgJ3pvb20tb3V0JywgJ29uZS10by1vbmUnLCAncmVzZXQnLCAncHJldicsICdwbGF5JywgJ25leHQnLCAncm90YXRlLWxlZnQnLCAncm90YXRlLXJpZ2h0JywgJ2ZsaXAtaG9yaXpvbnRhbCcsICdmbGlwLXZlcnRpY2FsJ107XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgc3RyaW5nLlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlci5cbiAqL1xudmFyIGlzTmFOID0gTnVtYmVyLmlzTmFOIHx8IFdJTkRPVy5pc05hTjtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyB1bmRlZmluZWQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyB1bmRlZmluZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gX3R5cGVvZih2YWx1ZSkgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsO1xufVxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIF9jb25zdHJ1Y3RvciA9IHZhbHVlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBwcm90b3R5cGUgPSBfY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIHJldHVybiBfY29uc3RydWN0b3IgJiYgcHJvdG90eXBlICYmIGhhc093blByb3BlcnR5LmNhbGwocHJvdG90eXBlLCAnaXNQcm90b3R5cGVPZicpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogSXRlcmF0ZSB0aGUgZ2l2ZW4gZGF0YS5cbiAqIEBwYXJhbSB7Kn0gZGF0YSAtIFRoZSBkYXRhIHRvIGl0ZXJhdGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBwcm9jZXNzIGZ1bmN0aW9uIGZvciBlYWNoIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Kn0gVGhlIG9yaWdpbmFsIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2goZGF0YSwgY2FsbGJhY2spIHtcbiAgaWYgKGRhdGEgJiYgaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc051bWJlcihkYXRhLmxlbmd0aCkgLyogYXJyYXktbGlrZSAqLykge1xuICAgICAgdmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgdmFyIGk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwoZGF0YSwgZGF0YVtpXSwgaSwgZGF0YSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChkYXRhLCBkYXRhW2tleV0sIGtleSwgZGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogRXh0ZW5kIHRoZSBnaXZlbiBvYmplY3QuXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWQuXG4gKiBAcGFyYW0geyp9IGFyZ3MgLSBUaGUgcmVzdCBvYmplY3RzIHdoaWNoIHdpbGwgYmUgbWVyZ2VkIHRvIHRoZSBmaXJzdCBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZXh0ZW5kZWQgb2JqZWN0LlxuICovXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBhc3NpZ24ob2JqKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICBpZiAoaXNPYmplY3Qob2JqKSAmJiBhcmdzLmxlbmd0aCA+IDApIHtcbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGFyZykge1xuICAgICAgaWYgKGlzT2JqZWN0KGFyZykpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoYXJnKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBvYmpba2V5XSA9IGFyZ1trZXldO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gb2JqO1xufTtcbnZhciBSRUdFWFBfU1VGRklYID0gL14oPzp3aWR0aHxoZWlnaHR8bGVmdHx0b3B8bWFyZ2luTGVmdHxtYXJnaW5Ub3ApJC87XG5cbi8qKlxuICogQXBwbHkgc3R5bGVzIHRvIHRoZSBnaXZlbiBlbGVtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIHRhcmdldCBlbGVtZW50LlxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlcyAtIFRoZSBzdHlsZXMgZm9yIGFwcGx5aW5nLlxuICovXG5mdW5jdGlvbiBzZXRTdHlsZShlbGVtZW50LCBzdHlsZXMpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgZm9yRWFjaChzdHlsZXMsIGZ1bmN0aW9uICh2YWx1ZSwgcHJvcGVydHkpIHtcbiAgICBpZiAoUkVHRVhQX1NVRkZJWC50ZXN0KHByb3BlcnR5KSAmJiBpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgIHZhbHVlICs9ICdweCc7XG4gICAgfVxuICAgIHN0eWxlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICB9KTtcbn1cblxuLyoqXG4gKiBFc2NhcGUgYSBzdHJpbmcgZm9yIHVzaW5nIGluIEhUTUwuXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgLSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlc2NhcGVIVE1MRW50aXRpZXModmFsdWUpIHtcbiAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSA/IHZhbHVlLnJlcGxhY2UoLyYoPyFhbXA7fHF1b3Q7fCMzOTt8bHQ7fGd0OykvZywgJyZhbXA7JykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpLnJlcGxhY2UoLycvZywgJyYjMzk7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKSA6IHZhbHVlO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBlbGVtZW50IGhhcyBhIHNwZWNpYWwgY2xhc3MuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byBjaGVjay5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBjbGFzcyB0byBzZWFyY2guXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNwZWNpYWwgY2xhc3Mgd2FzIGZvdW5kLlxuICovXG5mdW5jdGlvbiBoYXNDbGFzcyhlbGVtZW50LCB2YWx1ZSkge1xuICBpZiAoIWVsZW1lbnQgfHwgIXZhbHVlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdCA/IGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKHZhbHVlKSA6IGVsZW1lbnQuY2xhc3NOYW1lLmluZGV4T2YodmFsdWUpID4gLTE7XG59XG5cbi8qKlxuICogQWRkIGNsYXNzZXMgdG8gdGhlIGdpdmVuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgY2xhc3NlcyB0byBiZSBhZGRlZC5cbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgdmFsdWUpIHtcbiAgaWYgKCFlbGVtZW50IHx8ICF2YWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNOdW1iZXIoZWxlbWVudC5sZW5ndGgpKSB7XG4gICAgZm9yRWFjaChlbGVtZW50LCBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgYWRkQ2xhc3MoZWxlbSwgdmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQodmFsdWUpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUudHJpbSgpO1xuICBpZiAoIWNsYXNzTmFtZSkge1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gdmFsdWU7XG4gIH0gZWxzZSBpZiAoY2xhc3NOYW1lLmluZGV4T2YodmFsdWUpIDwgMCkge1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gXCJcIi5jb25jYXQoY2xhc3NOYW1lLCBcIiBcIikuY29uY2F0KHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzc2VzIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgY2xhc3NlcyB0byBiZSByZW1vdmVkLlxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCB2YWx1ZSkge1xuICBpZiAoIWVsZW1lbnQgfHwgIXZhbHVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc051bWJlcihlbGVtZW50Lmxlbmd0aCkpIHtcbiAgICBmb3JFYWNoKGVsZW1lbnQsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICByZW1vdmVDbGFzcyhlbGVtLCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSh2YWx1ZSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGVtZW50LmNsYXNzTmFtZS5pbmRleE9mKHZhbHVlKSA+PSAwKSB7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKHZhbHVlLCAnJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgb3IgcmVtb3ZlIGNsYXNzZXMgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSB0YXJnZXQgZWxlbWVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBjbGFzc2VzIHRvIGJlIHRvZ2dsZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFkZGVkIC0gQWRkIG9ubHkuXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsZW1lbnQsIHZhbHVlLCBhZGRlZCkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc051bWJlcihlbGVtZW50Lmxlbmd0aCkpIHtcbiAgICBmb3JFYWNoKGVsZW1lbnQsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICB0b2dnbGVDbGFzcyhlbGVtLCB2YWx1ZSwgYWRkZWQpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElFMTAtMTEgZG9lc24ndCBzdXBwb3J0IHRoZSBzZWNvbmQgcGFyYW1ldGVyIG9mIGBjbGFzc0xpc3QudG9nZ2xlYFxuICBpZiAoYWRkZWQpIHtcbiAgICBhZGRDbGFzcyhlbGVtZW50LCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgdmFsdWUpO1xuICB9XG59XG52YXIgUkVHRVhQX0hZUEhFTkFURSA9IC8oW2EtelxcZF0pKFtBLVpdKS9nO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZ2l2ZW4gc3RyaW5nIGZyb20gY2FtZWxDYXNlIHRvIGtlYmFiLWNhc2VcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdHJhbnNmb3JtZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShSRUdFWFBfSFlQSEVOQVRFLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIEdldCBkYXRhIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBkYXRhIGtleSB0byBnZXQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGF0YSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RGF0YShlbGVtZW50LCBuYW1lKSB7XG4gIGlmIChpc09iamVjdChlbGVtZW50W25hbWVdKSkge1xuICAgIHJldHVybiBlbGVtZW50W25hbWVdO1xuICB9XG4gIGlmIChlbGVtZW50LmRhdGFzZXQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5kYXRhc2V0W25hbWVdO1xuICB9XG4gIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtXCIuY29uY2F0KGh5cGhlbmF0ZShuYW1lKSkpO1xufVxuXG4vKipcbiAqIFNldCBkYXRhIHRvIHRoZSBnaXZlbiBlbGVtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIHRhcmdldCBlbGVtZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgZGF0YSBrZXkgdG8gc2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBUaGUgZGF0YSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc2V0RGF0YShlbGVtZW50LCBuYW1lLCBkYXRhKSB7XG4gIGlmIChpc09iamVjdChkYXRhKSkge1xuICAgIGVsZW1lbnRbbmFtZV0gPSBkYXRhO1xuICB9IGVsc2UgaWYgKGVsZW1lbnQuZGF0YXNldCkge1xuICAgIGVsZW1lbnQuZGF0YXNldFtuYW1lXSA9IGRhdGE7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLVwiLmNvbmNhdChoeXBoZW5hdGUobmFtZSkpLCBkYXRhKTtcbiAgfVxufVxudmFyIG9uY2VTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgaWYgKElTX0JST1dTRVIpIHtcbiAgICB2YXIgb25jZSA9IGZhbHNlO1xuICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIGxpc3RlbmVyKCkge307XG4gICAgdmFyIG9wdGlvbnMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdvbmNlJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBvbmNlO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBzZXR0ZXIgY2FuIGZpeCBhIGBUeXBlRXJyb3JgIGluIHN0cmljdCBtb2RlXG4gICAgICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRXJyb3JzL0dldHRlcl9vbmx5fVxuICAgICAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzZXRcbiAgICAgICAqL1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgb25jZSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFdJTkRPVy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIFdJTkRPVy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBzdXBwb3J0ZWQ7XG59KCk7XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVyIGZyb20gdGhlIHRhcmdldCBlbGVtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIGV2ZW50IHR5cGUocykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBldmVudCBsaXN0ZW5lci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIGV2ZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgdmFyIGhhbmRsZXIgPSBsaXN0ZW5lcjtcbiAgdHlwZS50cmltKCkuc3BsaXQoUkVHRVhQX1NQQUNFUykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoIW9uY2VTdXBwb3J0ZWQpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBlbGVtZW50Lmxpc3RlbmVycztcbiAgICAgIGlmIChsaXN0ZW5lcnMgJiYgbGlzdGVuZXJzW2V2ZW50XSAmJiBsaXN0ZW5lcnNbZXZlbnRdW2xpc3RlbmVyXSkge1xuICAgICAgICBoYW5kbGVyID0gbGlzdGVuZXJzW2V2ZW50XVtsaXN0ZW5lcl07XG4gICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbZXZlbnRdW2xpc3RlbmVyXTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGxpc3RlbmVyc1tldmVudF0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhsaXN0ZW5lcnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSBlbGVtZW50Lmxpc3RlbmVycztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBBZGQgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIHRhcmdldCBlbGVtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIGV2ZW50IHR5cGUocykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBldmVudCBsaXN0ZW5lci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIGV2ZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgdmFyIF9oYW5kbGVyID0gbGlzdGVuZXI7XG4gIHR5cGUudHJpbSgpLnNwbGl0KFJFR0VYUF9TUEFDRVMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKG9wdGlvbnMub25jZSAmJiAhb25jZVN1cHBvcnRlZCkge1xuICAgICAgdmFyIF9lbGVtZW50JGxpc3RlbmVycyA9IGVsZW1lbnQubGlzdGVuZXJzLFxuICAgICAgICBsaXN0ZW5lcnMgPSBfZWxlbWVudCRsaXN0ZW5lcnMgPT09IHZvaWQgMCA/IHt9IDogX2VsZW1lbnQkbGlzdGVuZXJzO1xuICAgICAgX2hhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICBkZWxldGUgbGlzdGVuZXJzW2V2ZW50XVtsaXN0ZW5lcl07XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgX2hhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cbiAgICAgICAgbGlzdGVuZXIuYXBwbHkoZWxlbWVudCwgYXJncyk7XG4gICAgICB9O1xuICAgICAgaWYgKCFsaXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgIGxpc3RlbmVyc1tldmVudF0gPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChsaXN0ZW5lcnNbZXZlbnRdW2xpc3RlbmVyXSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tldmVudF1bbGlzdGVuZXJdLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyc1tldmVudF1bbGlzdGVuZXJdID0gX2hhbmRsZXI7XG4gICAgICBlbGVtZW50Lmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICB9XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBfaGFuZGxlciwgb3B0aW9ucyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGV2ZW50IG9uIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBldmVudCB0eXBlKHMpLlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgYWRkaXRpb25hbCBldmVudCBkYXRhLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgYWRkaXRpb25hbCBldmVudCBvcHRpb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IEluZGljYXRlIGlmIHRoZSBldmVudCBpcyBkZWZhdWx0IHByZXZlbnRlZCBvciBub3QuXG4gKi9cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZWxlbWVudCwgdHlwZSwgZGF0YSwgb3B0aW9ucykge1xuICB2YXIgZXZlbnQ7XG5cbiAgLy8gRXZlbnQgYW5kIEN1c3RvbUV2ZW50IG9uIElFOS0xMSBhcmUgZ2xvYmFsIG9iamVjdHMsIG5vdCBjb25zdHJ1Y3RvcnNcbiAgaWYgKGlzRnVuY3Rpb24oRXZlbnQpICYmIGlzRnVuY3Rpb24oQ3VzdG9tRXZlbnQpKSB7XG4gICAgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQodHlwZSwgX29iamVjdFNwcmVhZDIoe1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBkZXRhaWw6IGRhdGFcbiAgICB9LCBvcHRpb25zKSk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSwgZGF0YSk7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvZmZzZXQgYmFzZSBvbiB0aGUgZG9jdW1lbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgb2Zmc2V0IGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE9mZnNldChlbGVtZW50KSB7XG4gIHZhciBib3ggPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IGJveC5sZWZ0ICsgKHdpbmRvdy5wYWdlWE9mZnNldCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRMZWZ0KSxcbiAgICB0b3A6IGJveC50b3AgKyAod2luZG93LnBhZ2VZT2Zmc2V0IC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFRvcClcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgdHJhbnNmb3JtcyBiYXNlIG9uIHRoZSBnaXZlbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gVGhlIHRhcmdldCBvYmplY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZyBjb250YWlucyB0cmFuc2Zvcm0gdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1zKF9yZWYpIHtcbiAgdmFyIHJvdGF0ZSA9IF9yZWYucm90YXRlLFxuICAgIHNjYWxlWCA9IF9yZWYuc2NhbGVYLFxuICAgIHNjYWxlWSA9IF9yZWYuc2NhbGVZLFxuICAgIHRyYW5zbGF0ZVggPSBfcmVmLnRyYW5zbGF0ZVgsXG4gICAgdHJhbnNsYXRlWSA9IF9yZWYudHJhbnNsYXRlWTtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICBpZiAoaXNOdW1iZXIodHJhbnNsYXRlWCkgJiYgdHJhbnNsYXRlWCAhPT0gMCkge1xuICAgIHZhbHVlcy5wdXNoKFwidHJhbnNsYXRlWChcIi5jb25jYXQodHJhbnNsYXRlWCwgXCJweClcIikpO1xuICB9XG4gIGlmIChpc051bWJlcih0cmFuc2xhdGVZKSAmJiB0cmFuc2xhdGVZICE9PSAwKSB7XG4gICAgdmFsdWVzLnB1c2goXCJ0cmFuc2xhdGVZKFwiLmNvbmNhdCh0cmFuc2xhdGVZLCBcInB4KVwiKSk7XG4gIH1cblxuICAvLyBSb3RhdGUgc2hvdWxkIGNvbWUgZmlyc3QgYmVmb3JlIHNjYWxlIHRvIG1hdGNoIG9yaWVudGF0aW9uIHRyYW5zZm9ybVxuICBpZiAoaXNOdW1iZXIocm90YXRlKSAmJiByb3RhdGUgIT09IDApIHtcbiAgICB2YWx1ZXMucHVzaChcInJvdGF0ZShcIi5jb25jYXQocm90YXRlLCBcImRlZylcIikpO1xuICB9XG4gIGlmIChpc051bWJlcihzY2FsZVgpICYmIHNjYWxlWCAhPT0gMSkge1xuICAgIHZhbHVlcy5wdXNoKFwic2NhbGVYKFwiLmNvbmNhdChzY2FsZVgsIFwiKVwiKSk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHNjYWxlWSkgJiYgc2NhbGVZICE9PSAxKSB7XG4gICAgdmFsdWVzLnB1c2goXCJzY2FsZVkoXCIuY29uY2F0KHNjYWxlWSwgXCIpXCIpKTtcbiAgfVxuICB2YXIgdHJhbnNmb3JtID0gdmFsdWVzLmxlbmd0aCA/IHZhbHVlcy5qb2luKCcgJykgOiAnbm9uZSc7XG4gIHJldHVybiB7XG4gICAgV2Via2l0VHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgbXNUcmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybVxuICB9O1xufVxuXG4vKipcbiAqIEdldCBhbiBpbWFnZSBuYW1lIGZyb20gYW4gaW1hZ2UgdXJsLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSB0YXJnZXQgdXJsLlxuICogQGV4YW1wbGVcbiAqIC8vIHBpY3R1cmUuanBnXG4gKiBnZXRJbWFnZU5hbWVGcm9tVVJMKCdodHRwczovL2RvbWFpbi5jb20vcGF0aC90by9waWN0dXJlLmpwZz9zaXplPTEyODDDlzk2MCcpXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZyBjb250YWlucyB0aGUgaW1hZ2UgbmFtZS5cbiAqL1xuZnVuY3Rpb24gZ2V0SW1hZ2VOYW1lRnJvbVVSTCh1cmwpIHtcbiAgcmV0dXJuIGlzU3RyaW5nKHVybCkgPyBkZWNvZGVVUklDb21wb25lbnQodXJsLnJlcGxhY2UoL14uKlxcLy8sICcnKS5yZXBsYWNlKC9bPyYjXS4qJC8sICcnKSkgOiAnJztcbn1cbnZhciBJU19TQUZBUkkgPSBXSU5ET1cubmF2aWdhdG9yICYmIC9WZXJzaW9uXFwvXFxkKyhcXC5cXGQrKSs/XFxzK1NhZmFyaS9pLnRlc3QoV0lORE9XLm5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIEdldCBhbiBpbWFnZSdzIG5hdHVyYWwgc2l6ZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gaW1hZ2UgLSBUaGUgdGFyZ2V0IGltYWdlLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgdmlld2VyIG9wdGlvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtIVE1MSW1hZ2VFbGVtZW50fSBUaGUgbmV3IGltYWdlLlxuICovXG5mdW5jdGlvbiBnZXRJbWFnZU5hdHVyYWxTaXplcyhpbWFnZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIG5ld0ltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG5cbiAgLy8gTW9kZXJuIGJyb3dzZXJzIChleGNlcHQgU2FmYXJpKVxuICBpZiAoaW1hZ2UubmF0dXJhbFdpZHRoICYmICFJU19TQUZBUkkpIHtcbiAgICBjYWxsYmFjayhpbWFnZS5uYXR1cmFsV2lkdGgsIGltYWdlLm5hdHVyYWxIZWlnaHQpO1xuICAgIHJldHVybiBuZXdJbWFnZTtcbiAgfVxuICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBuZXdJbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGJhY2sobmV3SW1hZ2Uud2lkdGgsIG5ld0ltYWdlLmhlaWdodCk7XG4gICAgaWYgKCFJU19TQUZBUkkpIHtcbiAgICAgIGJvZHkucmVtb3ZlQ2hpbGQobmV3SW1hZ2UpO1xuICAgIH1cbiAgfTtcbiAgZm9yRWFjaChvcHRpb25zLmluaGVyaXRlZEF0dHJpYnV0ZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gaW1hZ2UuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgbmV3SW1hZ2Uuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICBuZXdJbWFnZS5zcmMgPSBpbWFnZS5zcmM7XG5cbiAgLy8gaU9TIFNhZmFyaSB3aWxsIGNvbnZlcnQgdGhlIGltYWdlIGF1dG9tYXRpY2FsbHlcbiAgLy8gd2l0aCBpdHMgb3JpZW50YXRpb24gb25jZSBhcHBlbmQgaXQgaW50byBET01cbiAgaWYgKCFJU19TQUZBUkkpIHtcbiAgICBuZXdJbWFnZS5zdHlsZS5jc3NUZXh0ID0gJ2xlZnQ6MDsnICsgJ21heC1oZWlnaHQ6bm9uZSFpbXBvcnRhbnQ7JyArICdtYXgtd2lkdGg6bm9uZSFpbXBvcnRhbnQ7JyArICdtaW4taGVpZ2h0OjAhaW1wb3J0YW50OycgKyAnbWluLXdpZHRoOjAhaW1wb3J0YW50OycgKyAnb3BhY2l0eTowOycgKyAncG9zaXRpb246YWJzb2x1dGU7JyArICd0b3A6MDsnICsgJ3otaW5kZXg6LTE7JztcbiAgICBib2R5LmFwcGVuZENoaWxkKG5ld0ltYWdlKTtcbiAgfVxuICByZXR1cm4gbmV3SW1hZ2U7XG59XG5cbi8qKlxuICogR2V0IHRoZSByZWxhdGVkIGNsYXNzIG5hbWUgb2YgYSByZXNwb25zaXZlIHR5cGUgbnVtYmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgcmVzcG9uc2l2ZSB0eXBlLlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHJlbGF0ZWQgY2xhc3MgbmFtZS5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVzcG9uc2l2ZUNsYXNzKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIENMQVNTX0hJREVfWFNfRE9XTjtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gQ0xBU1NfSElERV9TTV9ET1dOO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBDTEFTU19ISURFX01EX0RPV047XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgbWF4IHJhdGlvIG9mIGEgZ3JvdXAgb2YgcG9pbnRlcnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcG9pbnRlcnMgLSBUaGUgdGFyZ2V0IHBvaW50ZXJzLlxuICogQHJldHVybnMge251bWJlcn0gVGhlIHJlc3VsdCByYXRpby5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF4Wm9vbVJhdGlvKHBvaW50ZXJzKSB7XG4gIHZhciBwb2ludGVyczIgPSBfb2JqZWN0U3ByZWFkMih7fSwgcG9pbnRlcnMpO1xuICB2YXIgcmF0aW9zID0gW107XG4gIGZvckVhY2gocG9pbnRlcnMsIGZ1bmN0aW9uIChwb2ludGVyLCBwb2ludGVySWQpIHtcbiAgICBkZWxldGUgcG9pbnRlcnMyW3BvaW50ZXJJZF07XG4gICAgZm9yRWFjaChwb2ludGVyczIsIGZ1bmN0aW9uIChwb2ludGVyMikge1xuICAgICAgdmFyIHgxID0gTWF0aC5hYnMocG9pbnRlci5zdGFydFggLSBwb2ludGVyMi5zdGFydFgpO1xuICAgICAgdmFyIHkxID0gTWF0aC5hYnMocG9pbnRlci5zdGFydFkgLSBwb2ludGVyMi5zdGFydFkpO1xuICAgICAgdmFyIHgyID0gTWF0aC5hYnMocG9pbnRlci5lbmRYIC0gcG9pbnRlcjIuZW5kWCk7XG4gICAgICB2YXIgeTIgPSBNYXRoLmFicyhwb2ludGVyLmVuZFkgLSBwb2ludGVyMi5lbmRZKTtcbiAgICAgIHZhciB6MSA9IE1hdGguc3FydCh4MSAqIHgxICsgeTEgKiB5MSk7XG4gICAgICB2YXIgejIgPSBNYXRoLnNxcnQoeDIgKiB4MiArIHkyICogeTIpO1xuICAgICAgdmFyIHJhdGlvID0gKHoyIC0gejEpIC8gejE7XG4gICAgICByYXRpb3MucHVzaChyYXRpbyk7XG4gICAgfSk7XG4gIH0pO1xuICByYXRpb3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBNYXRoLmFicyhhKSA8IE1hdGguYWJzKGIpO1xuICB9KTtcbiAgcmV0dXJuIHJhdGlvc1swXTtcbn1cblxuLyoqXG4gKiBHZXQgYSBwb2ludGVyIGZyb20gYW4gZXZlbnQgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gVGhlIHRhcmdldCBldmVudCBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVuZE9ubHkgLSBJbmRpY2F0ZXMgaWYgb25seSByZXR1cm5zIHRoZSBlbmQgcG9pbnQgY29vcmRpbmF0ZSBvciBub3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0IHBvaW50ZXIgY29udGFpbnMgc3RhcnQgYW5kL29yIGVuZCBwb2ludCBjb29yZGluYXRlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0UG9pbnRlcihfcmVmMiwgZW5kT25seSkge1xuICB2YXIgcGFnZVggPSBfcmVmMi5wYWdlWCxcbiAgICBwYWdlWSA9IF9yZWYyLnBhZ2VZO1xuICB2YXIgZW5kID0ge1xuICAgIGVuZFg6IHBhZ2VYLFxuICAgIGVuZFk6IHBhZ2VZXG4gIH07XG4gIHJldHVybiBlbmRPbmx5ID8gZW5kIDogX29iamVjdFNwcmVhZDIoe1xuICAgIHRpbWVTdGFtcDogRGF0ZS5ub3coKSxcbiAgICBzdGFydFg6IHBhZ2VYLFxuICAgIHN0YXJ0WTogcGFnZVlcbiAgfSwgZW5kKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNlbnRlciBwb2ludCBjb29yZGluYXRlIG9mIGEgZ3JvdXAgb2YgcG9pbnRlcnMuXG4gKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlcnMgLSBUaGUgdGFyZ2V0IHBvaW50ZXJzLlxuICogQHJldHVybnMge09iamVjdH0gVGhlIGNlbnRlciBwb2ludCBjb29yZGluYXRlLlxuICovXG5mdW5jdGlvbiBnZXRQb2ludGVyc0NlbnRlcihwb2ludGVycykge1xuICB2YXIgcGFnZVggPSAwO1xuICB2YXIgcGFnZVkgPSAwO1xuICB2YXIgY291bnQgPSAwO1xuICBmb3JFYWNoKHBvaW50ZXJzLCBmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICB2YXIgc3RhcnRYID0gX3JlZjMuc3RhcnRYLFxuICAgICAgc3RhcnRZID0gX3JlZjMuc3RhcnRZO1xuICAgIHBhZ2VYICs9IHN0YXJ0WDtcbiAgICBwYWdlWSArPSBzdGFydFk7XG4gICAgY291bnQgKz0gMTtcbiAgfSk7XG4gIHBhZ2VYIC89IGNvdW50O1xuICBwYWdlWSAvPSBjb3VudDtcbiAgcmV0dXJuIHtcbiAgICBwYWdlWDogcGFnZVgsXG4gICAgcGFnZVk6IHBhZ2VZXG4gIH07XG59XG5cbnZhciByZW5kZXIgPSB7XG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHRoaXMuaW5pdENvbnRhaW5lcigpO1xuICAgIHRoaXMuaW5pdFZpZXdlcigpO1xuICAgIHRoaXMuaW5pdExpc3QoKTtcbiAgICB0aGlzLnJlbmRlclZpZXdlcigpO1xuICB9LFxuICBpbml0Qm9keTogZnVuY3Rpb24gaW5pdEJvZHkoKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSB0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICB2YXIgYm9keSA9IG93bmVyRG9jdW1lbnQuYm9keSB8fCBvd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuc2Nyb2xsYmFyV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCAtIG93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIHRoaXMuaW5pdGlhbEJvZHlQYWRkaW5nUmlnaHQgPSBib2R5LnN0eWxlLnBhZGRpbmdSaWdodDtcbiAgICB0aGlzLmluaXRpYWxCb2R5Q29tcHV0ZWRQYWRkaW5nUmlnaHQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShib2R5KS5wYWRkaW5nUmlnaHQ7XG4gIH0sXG4gIGluaXRDb250YWluZXI6IGZ1bmN0aW9uIGluaXRDb250YWluZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXJEYXRhID0ge1xuICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICB9O1xuICB9LFxuICBpbml0Vmlld2VyOiBmdW5jdGlvbiBpbml0Vmlld2VyKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgdmFyIHZpZXdlckRhdGE7XG4gICAgaWYgKG9wdGlvbnMuaW5saW5lKSB7XG4gICAgICB2aWV3ZXJEYXRhID0ge1xuICAgICAgICB3aWR0aDogTWF0aC5tYXgocGFyZW50Lm9mZnNldFdpZHRoLCBvcHRpb25zLm1pbldpZHRoKSxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLm1heChwYXJlbnQub2Zmc2V0SGVpZ2h0LCBvcHRpb25zLm1pbkhlaWdodClcbiAgICAgIH07XG4gICAgICB0aGlzLnBhcmVudERhdGEgPSB2aWV3ZXJEYXRhO1xuICAgIH1cbiAgICBpZiAodGhpcy5mdWxsZWQgfHwgIXZpZXdlckRhdGEpIHtcbiAgICAgIHZpZXdlckRhdGEgPSB0aGlzLmNvbnRhaW5lckRhdGE7XG4gICAgfVxuICAgIHRoaXMudmlld2VyRGF0YSA9IGFzc2lnbih7fSwgdmlld2VyRGF0YSk7XG4gIH0sXG4gIHJlbmRlclZpZXdlcjogZnVuY3Rpb24gcmVuZGVyVmlld2VyKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuaW5saW5lICYmICF0aGlzLmZ1bGxlZCkge1xuICAgICAgc2V0U3R5bGUodGhpcy52aWV3ZXIsIHRoaXMudmlld2VyRGF0YSk7XG4gICAgfVxuICB9LFxuICBpbml0TGlzdDogZnVuY3Rpb24gaW5pdExpc3QoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICBsaXN0ID0gdGhpcy5saXN0O1xuICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgLy8gaW5pdExpc3QgbWF5IGJlIGNhbGxlZCBpbiB0aGlzLnVwZGF0ZSwgc28gc2hvdWxkIGtlZXAgaWRlbXBvdGVudFxuICAgIGxpc3QuaW5uZXJIVE1MID0gJyc7XG4gICAgZm9yRWFjaCh0aGlzLmltYWdlcywgZnVuY3Rpb24gKGltYWdlLCBpbmRleCkge1xuICAgICAgdmFyIHNyYyA9IGltYWdlLnNyYztcbiAgICAgIHZhciBhbHQgPSBpbWFnZS5hbHQgfHwgZ2V0SW1hZ2VOYW1lRnJvbVVSTChzcmMpO1xuICAgICAgdmFyIHVybCA9IF90aGlzLmdldEltYWdlVVJMKGltYWdlKTtcbiAgICAgIGlmIChzcmMgfHwgdXJsKSB7XG4gICAgICAgIHZhciBpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgICAgdmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICBmb3JFYWNoKG9wdGlvbnMuaW5oZXJpdGVkQXR0cmlidXRlcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBpbWFnZS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbWcuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3B0aW9ucy5uYXZiYXIpIHtcbiAgICAgICAgICBpbWcuc3JjID0gc3JjIHx8IHVybDtcbiAgICAgICAgfVxuICAgICAgICBpbWcuYWx0ID0gYWx0O1xuICAgICAgICBpbWcuc2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLXVybCcsIHVybCB8fCBzcmMpO1xuICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZSgnZGF0YS1pbmRleCcsIGluZGV4KTtcbiAgICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdmlld2VyLWFjdGlvbicsICd2aWV3Jyk7XG4gICAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xuICAgICAgICBpZiAob3B0aW9ucy5rZXlib2FyZCkge1xuICAgICAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIDApO1xuICAgICAgICB9XG4gICAgICAgIGl0ZW0uYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgICAgbGlzdC5hcHBlbmRDaGlsZChpdGVtKTtcbiAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgZm9yRWFjaChpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBpbWFnZSA9IGl0ZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICB2YXIgb25Mb2FkO1xuICAgICAgdmFyIG9uRXJyb3I7XG4gICAgICBzZXREYXRhKGltYWdlLCAnZmlsbGVkJywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5sb2FkaW5nKSB7XG4gICAgICAgIGFkZENsYXNzKGl0ZW0sIENMQVNTX0xPQURJTkcpO1xuICAgICAgfVxuICAgICAgYWRkTGlzdGVuZXIoaW1hZ2UsIEVWRU5UX0xPQUQsIG9uTG9hZCA9IGZ1bmN0aW9uIG9uTG9hZChldmVudCkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihpbWFnZSwgRVZFTlRfRVJST1IsIG9uRXJyb3IpO1xuICAgICAgICBpZiAob3B0aW9ucy5sb2FkaW5nKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoaXRlbSwgQ0xBU1NfTE9BRElORyk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMubG9hZEltYWdlKGV2ZW50KTtcbiAgICAgIH0sIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBhZGRMaXN0ZW5lcihpbWFnZSwgRVZFTlRfRVJST1IsIG9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKCkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihpbWFnZSwgRVZFTlRfTE9BRCwgb25Mb2FkKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubG9hZGluZykge1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGl0ZW0sIENMQVNTX0xPQURJTkcpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24pIHtcbiAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX1ZJRVdFRCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBhZGRDbGFzcyhsaXN0LCBDTEFTU19UUkFOU0lUSU9OKTtcbiAgICAgIH0sIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICByZW5kZXJMaXN0OiBmdW5jdGlvbiByZW5kZXJMaXN0KCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1zW2luZGV4XTtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5leHQgPSBpdGVtLm5leHRFbGVtZW50U2libGluZztcbiAgICB2YXIgZ3V0dGVyID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUobmV4dCB8fCBpdGVtKS5tYXJnaW5MZWZ0LCAxMCk7XG4gICAgdmFyIG9mZnNldFdpZHRoID0gaXRlbS5vZmZzZXRXaWR0aDtcbiAgICB2YXIgb3V0ZXJXaWR0aCA9IG9mZnNldFdpZHRoICsgZ3V0dGVyO1xuXG4gICAgLy8gUGxhY2UgdGhlIGFjdGl2ZSBpdGVtIGluIHRoZSBjZW50ZXIgb2YgdGhlIHNjcmVlblxuICAgIHNldFN0eWxlKHRoaXMubGlzdCwgYXNzaWduKHtcbiAgICAgIHdpZHRoOiBvdXRlcldpZHRoICogdGhpcy5sZW5ndGggLSBndXR0ZXJcbiAgICB9LCBnZXRUcmFuc2Zvcm1zKHtcbiAgICAgIHRyYW5zbGF0ZVg6ICh0aGlzLnZpZXdlckRhdGEud2lkdGggLSBvZmZzZXRXaWR0aCkgLyAyIC0gb3V0ZXJXaWR0aCAqIGluZGV4XG4gICAgfSkpKTtcbiAgfSxcbiAgcmVzZXRMaXN0OiBmdW5jdGlvbiByZXNldExpc3QoKSB7XG4gICAgdmFyIGxpc3QgPSB0aGlzLmxpc3Q7XG4gICAgbGlzdC5pbm5lckhUTUwgPSAnJztcbiAgICByZW1vdmVDbGFzcyhsaXN0LCBDTEFTU19UUkFOU0lUSU9OKTtcbiAgICBzZXRTdHlsZShsaXN0LCBnZXRUcmFuc2Zvcm1zKHtcbiAgICAgIHRyYW5zbGF0ZVg6IDBcbiAgICB9KSk7XG4gIH0sXG4gIGluaXRJbWFnZTogZnVuY3Rpb24gaW5pdEltYWdlKGRvbmUpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIGltYWdlID0gdGhpcy5pbWFnZSxcbiAgICAgIHZpZXdlckRhdGEgPSB0aGlzLnZpZXdlckRhdGE7XG4gICAgdmFyIGZvb3RlckhlaWdodCA9IHRoaXMuZm9vdGVyLm9mZnNldEhlaWdodDtcbiAgICB2YXIgdmlld2VyV2lkdGggPSB2aWV3ZXJEYXRhLndpZHRoO1xuICAgIHZhciB2aWV3ZXJIZWlnaHQgPSBNYXRoLm1heCh2aWV3ZXJEYXRhLmhlaWdodCAtIGZvb3RlckhlaWdodCwgZm9vdGVySGVpZ2h0KTtcbiAgICB2YXIgb2xkSW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGEgfHwge307XG4gICAgdmFyIHNpemluZ0ltYWdlO1xuICAgIHRoaXMuaW1hZ2VJbml0aWFsaXppbmcgPSB7XG4gICAgICBhYm9ydDogZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICAgIHNpemluZ0ltYWdlLm9ubG9hZCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICBzaXppbmdJbWFnZSA9IGdldEltYWdlTmF0dXJhbFNpemVzKGltYWdlLCBvcHRpb25zLCBmdW5jdGlvbiAobmF0dXJhbFdpZHRoLCBuYXR1cmFsSGVpZ2h0KSB7XG4gICAgICB2YXIgYXNwZWN0UmF0aW8gPSBuYXR1cmFsV2lkdGggLyBuYXR1cmFsSGVpZ2h0O1xuICAgICAgdmFyIGluaXRpYWxDb3ZlcmFnZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIG9wdGlvbnMuaW5pdGlhbENvdmVyYWdlKSk7XG4gICAgICB2YXIgd2lkdGggPSB2aWV3ZXJXaWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSB2aWV3ZXJIZWlnaHQ7XG4gICAgICBfdGhpczIuaW1hZ2VJbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICAgIGlmICh2aWV3ZXJIZWlnaHQgKiBhc3BlY3RSYXRpbyA+IHZpZXdlcldpZHRoKSB7XG4gICAgICAgIGhlaWdodCA9IHZpZXdlcldpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aCA9IHZpZXdlckhlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgfVxuICAgICAgaW5pdGlhbENvdmVyYWdlID0gaXNOdW1iZXIoaW5pdGlhbENvdmVyYWdlKSA/IGluaXRpYWxDb3ZlcmFnZSA6IDAuOTtcbiAgICAgIHdpZHRoID0gTWF0aC5taW4od2lkdGggKiBpbml0aWFsQ292ZXJhZ2UsIG5hdHVyYWxXaWR0aCk7XG4gICAgICBoZWlnaHQgPSBNYXRoLm1pbihoZWlnaHQgKiBpbml0aWFsQ292ZXJhZ2UsIG5hdHVyYWxIZWlnaHQpO1xuICAgICAgdmFyIGxlZnQgPSAodmlld2VyV2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgdmFyIHRvcCA9ICh2aWV3ZXJIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgIHZhciBpbWFnZURhdGEgPSB7XG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICB4OiBsZWZ0LFxuICAgICAgICB5OiB0b3AsXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIG9sZFJhdGlvOiAxLFxuICAgICAgICByYXRpbzogd2lkdGggLyBuYXR1cmFsV2lkdGgsXG4gICAgICAgIGFzcGVjdFJhdGlvOiBhc3BlY3RSYXRpbyxcbiAgICAgICAgbmF0dXJhbFdpZHRoOiBuYXR1cmFsV2lkdGgsXG4gICAgICAgIG5hdHVyYWxIZWlnaHQ6IG5hdHVyYWxIZWlnaHRcbiAgICAgIH07XG4gICAgICB2YXIgaW5pdGlhbEltYWdlRGF0YSA9IGFzc2lnbih7fSwgaW1hZ2VEYXRhKTtcbiAgICAgIGlmIChvcHRpb25zLnJvdGF0YWJsZSkge1xuICAgICAgICBpbWFnZURhdGEucm90YXRlID0gb2xkSW1hZ2VEYXRhLnJvdGF0ZSB8fCAwO1xuICAgICAgICBpbml0aWFsSW1hZ2VEYXRhLnJvdGF0ZSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zY2FsYWJsZSkge1xuICAgICAgICBpbWFnZURhdGEuc2NhbGVYID0gb2xkSW1hZ2VEYXRhLnNjYWxlWCB8fCAxO1xuICAgICAgICBpbWFnZURhdGEuc2NhbGVZID0gb2xkSW1hZ2VEYXRhLnNjYWxlWSB8fCAxO1xuICAgICAgICBpbml0aWFsSW1hZ2VEYXRhLnNjYWxlWCA9IDE7XG4gICAgICAgIGluaXRpYWxJbWFnZURhdGEuc2NhbGVZID0gMTtcbiAgICAgIH1cbiAgICAgIF90aGlzMi5pbWFnZURhdGEgPSBpbWFnZURhdGE7XG4gICAgICBfdGhpczIuaW5pdGlhbEltYWdlRGF0YSA9IGluaXRpYWxJbWFnZURhdGE7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBkb25lKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIHJlbmRlckltYWdlOiBmdW5jdGlvbiByZW5kZXJJbWFnZShkb25lKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZSxcbiAgICAgIGltYWdlRGF0YSA9IHRoaXMuaW1hZ2VEYXRhO1xuICAgIHNldFN0eWxlKGltYWdlLCBhc3NpZ24oe1xuICAgICAgd2lkdGg6IGltYWdlRGF0YS53aWR0aCxcbiAgICAgIGhlaWdodDogaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgIC8vIFhYWDogTm90IHRvIHVzZSB0cmFuc2xhdGVYL1kgdG8gYXZvaWQgaW1hZ2Ugc2hha2luZyB3aGVuIHpvb21pbmdcbiAgICAgIG1hcmdpbkxlZnQ6IGltYWdlRGF0YS54LFxuICAgICAgbWFyZ2luVG9wOiBpbWFnZURhdGEueVxuICAgIH0sIGdldFRyYW5zZm9ybXMoaW1hZ2VEYXRhKSkpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICBpZiAoKHRoaXMudmlld2luZyB8fCB0aGlzLm1vdmluZyB8fCB0aGlzLnJvdGF0aW5nIHx8IHRoaXMuc2NhbGluZyB8fCB0aGlzLnpvb21pbmcpICYmIHRoaXMub3B0aW9ucy50cmFuc2l0aW9uICYmIGhhc0NsYXNzKGltYWdlLCBDTEFTU19UUkFOU0lUSU9OKSkge1xuICAgICAgICB2YXIgb25UcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gb25UcmFuc2l0aW9uRW5kKCkge1xuICAgICAgICAgIF90aGlzMy5pbWFnZVJlbmRlcmluZyA9IGZhbHNlO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pbWFnZVJlbmRlcmluZyA9IHtcbiAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lcihpbWFnZSwgRVZFTlRfVFJBTlNJVElPTl9FTkQsIG9uVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBhZGRMaXN0ZW5lcihpbWFnZSwgRVZFTlRfVFJBTlNJVElPTl9FTkQsIG9uVHJhbnNpdGlvbkVuZCwge1xuICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICByZXNldEltYWdlOiBmdW5jdGlvbiByZXNldEltYWdlKCkge1xuICAgIHZhciBpbWFnZSA9IHRoaXMuaW1hZ2U7XG4gICAgaWYgKGltYWdlKSB7XG4gICAgICBpZiAodGhpcy52aWV3aW5nKSB7XG4gICAgICAgIHRoaXMudmlld2luZy5hYm9ydCgpO1xuICAgICAgfVxuICAgICAgaW1hZ2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpbWFnZSk7XG4gICAgICB0aGlzLmltYWdlID0gbnVsbDtcbiAgICAgIHRoaXMudGl0bGUuaW5uZXJIVE1MID0gJyc7XG4gICAgfVxuICB9XG59O1xuXG52YXIgZXZlbnRzID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgdmlld2VyID0gdGhpcy52aWV3ZXIsXG4gICAgICBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICBhZGRMaXN0ZW5lcih2aWV3ZXIsIEVWRU5UX0NMSUNLLCB0aGlzLm9uQ2xpY2sgPSB0aGlzLmNsaWNrLmJpbmQodGhpcykpO1xuICAgIGFkZExpc3RlbmVyKHZpZXdlciwgRVZFTlRfRFJBR19TVEFSVCwgdGhpcy5vbkRyYWdTdGFydCA9IHRoaXMuZHJhZ3N0YXJ0LmJpbmQodGhpcykpO1xuICAgIGFkZExpc3RlbmVyKGNhbnZhcywgRVZFTlRfUE9JTlRFUl9ET1dOLCB0aGlzLm9uUG9pbnRlckRvd24gPSB0aGlzLnBvaW50ZXJkb3duLmJpbmQodGhpcykpO1xuICAgIGFkZExpc3RlbmVyKGRvY3VtZW50LCBFVkVOVF9QT0lOVEVSX01PVkUsIHRoaXMub25Qb2ludGVyTW92ZSA9IHRoaXMucG9pbnRlcm1vdmUuYmluZCh0aGlzKSk7XG4gICAgYWRkTGlzdGVuZXIoZG9jdW1lbnQsIEVWRU5UX1BPSU5URVJfVVAsIHRoaXMub25Qb2ludGVyVXAgPSB0aGlzLnBvaW50ZXJ1cC5iaW5kKHRoaXMpKTtcbiAgICBhZGRMaXN0ZW5lcihkb2N1bWVudCwgRVZFTlRfS0VZX0RPV04sIHRoaXMub25LZXlEb3duID0gdGhpcy5rZXlkb3duLmJpbmQodGhpcykpO1xuICAgIGFkZExpc3RlbmVyKHdpbmRvdywgRVZFTlRfUkVTSVpFLCB0aGlzLm9uUmVzaXplID0gdGhpcy5yZXNpemUuYmluZCh0aGlzKSk7XG4gICAgaWYgKG9wdGlvbnMuem9vbWFibGUgJiYgb3B0aW9ucy56b29tT25XaGVlbCkge1xuICAgICAgYWRkTGlzdGVuZXIodmlld2VyLCBFVkVOVF9XSEVFTCwgdGhpcy5vbldoZWVsID0gdGhpcy53aGVlbC5iaW5kKHRoaXMpLCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudG9nZ2xlT25EYmxjbGljaykge1xuICAgICAgYWRkTGlzdGVuZXIoY2FudmFzLCBFVkVOVF9EQkxDTElDSywgdGhpcy5vbkRibGNsaWNrID0gdGhpcy5kYmxjbGljay5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH0sXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgdmlld2VyID0gdGhpcy52aWV3ZXIsXG4gICAgICBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICByZW1vdmVMaXN0ZW5lcih2aWV3ZXIsIEVWRU5UX0NMSUNLLCB0aGlzLm9uQ2xpY2spO1xuICAgIHJlbW92ZUxpc3RlbmVyKHZpZXdlciwgRVZFTlRfRFJBR19TVEFSVCwgdGhpcy5vbkRyYWdTdGFydCk7XG4gICAgcmVtb3ZlTGlzdGVuZXIoY2FudmFzLCBFVkVOVF9QT0lOVEVSX0RPV04sIHRoaXMub25Qb2ludGVyRG93bik7XG4gICAgcmVtb3ZlTGlzdGVuZXIoZG9jdW1lbnQsIEVWRU5UX1BPSU5URVJfTU9WRSwgdGhpcy5vblBvaW50ZXJNb3ZlKTtcbiAgICByZW1vdmVMaXN0ZW5lcihkb2N1bWVudCwgRVZFTlRfUE9JTlRFUl9VUCwgdGhpcy5vblBvaW50ZXJVcCk7XG4gICAgcmVtb3ZlTGlzdGVuZXIoZG9jdW1lbnQsIEVWRU5UX0tFWV9ET1dOLCB0aGlzLm9uS2V5RG93bik7XG4gICAgcmVtb3ZlTGlzdGVuZXIod2luZG93LCBFVkVOVF9SRVNJWkUsIHRoaXMub25SZXNpemUpO1xuICAgIGlmIChvcHRpb25zLnpvb21hYmxlICYmIG9wdGlvbnMuem9vbU9uV2hlZWwpIHtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKHZpZXdlciwgRVZFTlRfV0hFRUwsIHRoaXMub25XaGVlbCwge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRvZ2dsZU9uRGJsY2xpY2spIHtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGNhbnZhcywgRVZFTlRfREJMQ0xJQ0ssIHRoaXMub25EYmxjbGljayk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgaGFuZGxlcnMgPSB7XG4gIGNsaWNrOiBmdW5jdGlvbiBjbGljayhldmVudCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgaW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGE7XG4gICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICB2YXIgYWN0aW9uID0gZ2V0RGF0YSh0YXJnZXQsIERBVEFfQUNUSU9OKTtcbiAgICBpZiAoIWFjdGlvbiAmJiB0YXJnZXQubG9jYWxOYW1lID09PSAnaW1nJyAmJiB0YXJnZXQucGFyZW50RWxlbWVudC5sb2NhbE5hbWUgPT09ICdsaScpIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnRFbGVtZW50O1xuICAgICAgYWN0aW9uID0gZ2V0RGF0YSh0YXJnZXQsIERBVEFfQUNUSU9OKTtcbiAgICB9XG5cbiAgICAvLyBDYW5jZWwgdGhlIGVtdWxhdGVkIGNsaWNrIHdoZW4gdGhlIG5hdGl2ZSBjbGljayBldmVudCB3YXMgdHJpZ2dlcmVkLlxuICAgIGlmIChJU19UT1VDSF9ERVZJQ0UgJiYgZXZlbnQuaXNUcnVzdGVkICYmIHRhcmdldCA9PT0gdGhpcy5jYW52YXMpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNsaWNrQ2FudmFzVGltZW91dCk7XG4gICAgfVxuICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICBjYXNlICdtaXgnOlxuICAgICAgICBpZiAodGhpcy5wbGF5ZWQpIHtcbiAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmlubGluZSkge1xuICAgICAgICAgIGlmICh0aGlzLmZ1bGxlZCkge1xuICAgICAgICAgICAgdGhpcy5leGl0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZnVsbCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2hpZGUnOlxuICAgICAgICBpZiAoIXRoaXMucG9pbnRlck1vdmVkKSB7XG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd2aWV3JzpcbiAgICAgICAgdGhpcy52aWV3KGdldERhdGEodGFyZ2V0LCAnaW5kZXgnKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnem9vbS1pbic6XG4gICAgICAgIHRoaXMuem9vbSgwLjEsIHRydWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3pvb20tb3V0JzpcbiAgICAgICAgdGhpcy56b29tKC0wLjEsIHRydWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29uZS10by1vbmUnOlxuICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Jlc2V0JzpcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3ByZXYnOlxuICAgICAgICB0aGlzLnByZXYob3B0aW9ucy5sb29wKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwbGF5JzpcbiAgICAgICAgdGhpcy5wbGF5KG9wdGlvbnMuZnVsbHNjcmVlbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbmV4dCc6XG4gICAgICAgIHRoaXMubmV4dChvcHRpb25zLmxvb3ApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JvdGF0ZS1sZWZ0JzpcbiAgICAgICAgdGhpcy5yb3RhdGUoLTkwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyb3RhdGUtcmlnaHQnOlxuICAgICAgICB0aGlzLnJvdGF0ZSg5MCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZmxpcC1ob3Jpem9udGFsJzpcbiAgICAgICAgdGhpcy5zY2FsZVgoLWltYWdlRGF0YS5zY2FsZVggfHwgLTEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ZsaXAtdmVydGljYWwnOlxuICAgICAgICB0aGlzLnNjYWxlWSgtaW1hZ2VEYXRhLnNjYWxlWSB8fCAtMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHRoaXMucGxheWVkKSB7XG4gICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRibGNsaWNrOiBmdW5jdGlvbiBkYmxjbGljayhldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKHRoaXMudmlld2VkICYmIGV2ZW50LnRhcmdldCA9PT0gdGhpcy5pbWFnZSkge1xuICAgICAgLy8gQ2FuY2VsIHRoZSBlbXVsYXRlZCBkb3VibGUgY2xpY2sgd2hlbiB0aGUgbmF0aXZlIGRibGNsaWNrIGV2ZW50IHdhcyB0cmlnZ2VyZWQuXG4gICAgICBpZiAoSVNfVE9VQ0hfREVWSUNFICYmIGV2ZW50LmlzVHJ1c3RlZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kb3VibGVDbGlja0ltYWdlVGltZW91dCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFhYWDogTm8gcGFnZVgvWSBwcm9wZXJ0aWVzIGluIGN1c3RvbSBldmVudCwgZmFsbGJhY2sgdG8gdGhlIG9yaWdpbmFsIGV2ZW50LlxuICAgICAgdGhpcy50b2dnbGUoZXZlbnQuaXNUcnVzdGVkID8gZXZlbnQgOiBldmVudC5kZXRhaWwgJiYgZXZlbnQuZGV0YWlsLm9yaWdpbmFsRXZlbnQpO1xuICAgIH1cbiAgfSxcbiAgbG9hZDogZnVuY3Rpb24gbG9hZCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgdGhpcy50aW1lb3V0ID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIGltYWdlID0gdGhpcy5pbWFnZSxcbiAgICAgIGluZGV4ID0gdGhpcy5pbmRleCxcbiAgICAgIHZpZXdlckRhdGEgPSB0aGlzLnZpZXdlckRhdGE7XG4gICAgcmVtb3ZlQ2xhc3MoaW1hZ2UsIENMQVNTX0lOVklTSUJMRSk7XG4gICAgaWYgKG9wdGlvbnMubG9hZGluZykge1xuICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5jYW52YXMsIENMQVNTX0xPQURJTkcpO1xuICAgIH1cbiAgICBpbWFnZS5zdHlsZS5jc3NUZXh0ID0gJ2hlaWdodDowOycgKyBcIm1hcmdpbi1sZWZ0OlwiLmNvbmNhdCh2aWV3ZXJEYXRhLndpZHRoIC8gMiwgXCJweDtcIikgKyBcIm1hcmdpbi10b3A6XCIuY29uY2F0KHZpZXdlckRhdGEuaGVpZ2h0IC8gMiwgXCJweDtcIikgKyAnbWF4LXdpZHRoOm5vbmUhaW1wb3J0YW50OycgKyAncG9zaXRpb246cmVsYXRpdmU7JyArICd3aWR0aDowOyc7XG4gICAgdGhpcy5pbml0SW1hZ2UoZnVuY3Rpb24gKCkge1xuICAgICAgdG9nZ2xlQ2xhc3MoaW1hZ2UsIENMQVNTX01PVkUsIG9wdGlvbnMubW92YWJsZSk7XG4gICAgICB0b2dnbGVDbGFzcyhpbWFnZSwgQ0xBU1NfVFJBTlNJVElPTiwgb3B0aW9ucy50cmFuc2l0aW9uKTtcbiAgICAgIF90aGlzLnJlbmRlckltYWdlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMudmlld2VkID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMudmlld2luZyA9IGZhbHNlO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLnZpZXdlZCkpIHtcbiAgICAgICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9WSUVXRUQsIG9wdGlvbnMudmlld2VkLCB7XG4gICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZGlzcGF0Y2hFdmVudChlbGVtZW50LCBFVkVOVF9WSUVXRUQsIHtcbiAgICAgICAgICBvcmlnaW5hbEltYWdlOiBfdGhpcy5pbWFnZXNbaW5kZXhdLFxuICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICBpbWFnZTogaW1hZ2VcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG4gIGxvYWRJbWFnZTogZnVuY3Rpb24gbG9hZEltYWdlKGV2ZW50KSB7XG4gICAgdmFyIGltYWdlID0gZXZlbnQudGFyZ2V0O1xuICAgIHZhciBwYXJlbnQgPSBpbWFnZS5wYXJlbnROb2RlO1xuICAgIHZhciBwYXJlbnRXaWR0aCA9IHBhcmVudC5vZmZzZXRXaWR0aCB8fCAzMDtcbiAgICB2YXIgcGFyZW50SGVpZ2h0ID0gcGFyZW50Lm9mZnNldEhlaWdodCB8fCA1MDtcbiAgICB2YXIgZmlsbGVkID0gISFnZXREYXRhKGltYWdlLCAnZmlsbGVkJyk7XG4gICAgZ2V0SW1hZ2VOYXR1cmFsU2l6ZXMoaW1hZ2UsIHRoaXMub3B0aW9ucywgZnVuY3Rpb24gKG5hdHVyYWxXaWR0aCwgbmF0dXJhbEhlaWdodCkge1xuICAgICAgdmFyIGFzcGVjdFJhdGlvID0gbmF0dXJhbFdpZHRoIC8gbmF0dXJhbEhlaWdodDtcbiAgICAgIHZhciB3aWR0aCA9IHBhcmVudFdpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IHBhcmVudEhlaWdodDtcbiAgICAgIGlmIChwYXJlbnRIZWlnaHQgKiBhc3BlY3RSYXRpbyA+IHBhcmVudFdpZHRoKSB7XG4gICAgICAgIGlmIChmaWxsZWQpIHtcbiAgICAgICAgICB3aWR0aCA9IHBhcmVudEhlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhlaWdodCA9IHBhcmVudFdpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZmlsbGVkKSB7XG4gICAgICAgIGhlaWdodCA9IHBhcmVudFdpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aCA9IHBhcmVudEhlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgfVxuICAgICAgc2V0U3R5bGUoaW1hZ2UsIGFzc2lnbih7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH0sIGdldFRyYW5zZm9ybXMoe1xuICAgICAgICB0cmFuc2xhdGVYOiAocGFyZW50V2lkdGggLSB3aWR0aCkgLyAyLFxuICAgICAgICB0cmFuc2xhdGVZOiAocGFyZW50SGVpZ2h0IC0gaGVpZ2h0KSAvIDJcbiAgICAgIH0pKSk7XG4gICAgfSk7XG4gIH0sXG4gIGtleWRvd246IGZ1bmN0aW9uIGtleWRvd24oZXZlbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoIW9wdGlvbnMua2V5Ym9hcmQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGtleUNvZGUgPSBldmVudC5rZXlDb2RlIHx8IGV2ZW50LndoaWNoIHx8IGV2ZW50LmNoYXJDb2RlO1xuICAgIHN3aXRjaCAoa2V5Q29kZSkge1xuICAgICAgLy8gRW50ZXJcbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIGlmICh0aGlzLnZpZXdlci5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgdGhpcy5jbGljayhldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghdGhpcy5mdWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChrZXlDb2RlKSB7XG4gICAgICAvLyBFc2NhcGVcbiAgICAgIGNhc2UgMjc6XG4gICAgICAgIGlmICh0aGlzLnBsYXllZCkge1xuICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaW5saW5lKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZnVsbGVkKSB7XG4gICAgICAgICAgICB0aGlzLmV4aXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIFNwYWNlXG4gICAgICBjYXNlIDMyOlxuICAgICAgICBpZiAodGhpcy5wbGF5ZWQpIHtcbiAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgLy8gQXJyb3dMZWZ0XG4gICAgICBjYXNlIDM3OlxuICAgICAgICBpZiAodGhpcy5wbGF5ZWQgJiYgdGhpcy5wbGF5aW5nKSB7XG4gICAgICAgICAgdGhpcy5wbGF5aW5nLnByZXYoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnByZXYob3B0aW9ucy5sb29wKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgLy8gQXJyb3dVcFxuICAgICAgY2FzZSAzODpcbiAgICAgICAgLy8gUHJldmVudCBzY3JvbGwgb24gRmlyZWZveFxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIFpvb20gaW5cbiAgICAgICAgdGhpcy56b29tKG9wdGlvbnMuem9vbVJhdGlvLCB0cnVlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIEFycm93UmlnaHRcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIGlmICh0aGlzLnBsYXllZCAmJiB0aGlzLnBsYXlpbmcpIHtcbiAgICAgICAgICB0aGlzLnBsYXlpbmcubmV4dCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubmV4dChvcHRpb25zLmxvb3ApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBBcnJvd0Rvd25cbiAgICAgIGNhc2UgNDA6XG4gICAgICAgIC8vIFByZXZlbnQgc2Nyb2xsIG9uIEZpcmVmb3hcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBab29tIG91dFxuICAgICAgICB0aGlzLnpvb20oLW9wdGlvbnMuem9vbVJhdGlvLCB0cnVlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIEN0cmwgKyAwXG4gICAgICBjYXNlIDQ4OlxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICAgIC8vIEN0cmwgKyAxXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgIGNhc2UgNDk6XG4gICAgICAgIGlmIChldmVudC5jdHJsS2V5KSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcbiAgZHJhZ3N0YXJ0OiBmdW5jdGlvbiBkcmFnc3RhcnQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0LmxvY2FsTmFtZSA9PT0gJ2ltZycpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LFxuICBwb2ludGVyZG93bjogZnVuY3Rpb24gcG9pbnRlcmRvd24oZXZlbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIHBvaW50ZXJzID0gdGhpcy5wb2ludGVycztcbiAgICB2YXIgYnV0dG9ucyA9IGV2ZW50LmJ1dHRvbnMsXG4gICAgICBidXR0b24gPSBldmVudC5idXR0b247XG4gICAgdGhpcy5wb2ludGVyTW92ZWQgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMudmlld2VkIHx8IHRoaXMuc2hvd2luZyB8fCB0aGlzLnZpZXdpbmcgfHwgdGhpcy5oaWRpbmdcblxuICAgIC8vIEhhbmRsZSBtb3VzZSBldmVudCBhbmQgcG9pbnRlciBldmVudCBhbmQgaWdub3JlIHRvdWNoIGV2ZW50XG4gICAgfHwgKGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdwb2ludGVyZG93bicgJiYgZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScpICYmIChcbiAgICAvLyBObyBwcmltYXJ5IGJ1dHRvbiAoVXN1YWxseSB0aGUgbGVmdCBidXR0b24pXG4gICAgaXNOdW1iZXIoYnV0dG9ucykgJiYgYnV0dG9ucyAhPT0gMSB8fCBpc051bWJlcihidXR0b24pICYmIGJ1dHRvbiAhPT0gMFxuXG4gICAgLy8gT3BlbiBjb250ZXh0IG1lbnVcbiAgICB8fCBldmVudC5jdHJsS2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByZXZlbnQgZGVmYXVsdCBiZWhhdmlvdXJzIGFzIHBhZ2Ugem9vbWluZyBpbiB0b3VjaCBkZXZpY2VzLlxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKGV2ZW50LmNoYW5nZWRUb3VjaGVzKSB7XG4gICAgICBmb3JFYWNoKGV2ZW50LmNoYW5nZWRUb3VjaGVzLCBmdW5jdGlvbiAodG91Y2gpIHtcbiAgICAgICAgcG9pbnRlcnNbdG91Y2guaWRlbnRpZmllcl0gPSBnZXRQb2ludGVyKHRvdWNoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludGVyc1tldmVudC5wb2ludGVySWQgfHwgMF0gPSBnZXRQb2ludGVyKGV2ZW50KTtcbiAgICB9XG4gICAgdmFyIGFjdGlvbiA9IG9wdGlvbnMubW92YWJsZSA/IEFDVElPTl9NT1ZFIDogZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMuem9vbU9uVG91Y2ggJiYgb3B0aW9ucy56b29tYWJsZSAmJiBPYmplY3Qua2V5cyhwb2ludGVycykubGVuZ3RoID4gMSkge1xuICAgICAgYWN0aW9uID0gQUNUSU9OX1pPT007XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNsaWRlT25Ub3VjaCAmJiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgfHwgZXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSAmJiB0aGlzLmlzU3dpdGNoYWJsZSgpKSB7XG4gICAgICBhY3Rpb24gPSBBQ1RJT05fU1dJVENIO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uICYmIChhY3Rpb24gPT09IEFDVElPTl9NT1ZFIHx8IGFjdGlvbiA9PT0gQUNUSU9OX1pPT00pKSB7XG4gICAgICByZW1vdmVDbGFzcyh0aGlzLmltYWdlLCBDTEFTU19UUkFOU0lUSU9OKTtcbiAgICB9XG4gICAgdGhpcy5hY3Rpb24gPSBhY3Rpb247XG4gIH0sXG4gIHBvaW50ZXJtb3ZlOiBmdW5jdGlvbiBwb2ludGVybW92ZShldmVudCkge1xuICAgIHZhciBwb2ludGVycyA9IHRoaXMucG9pbnRlcnMsXG4gICAgICBhY3Rpb24gPSB0aGlzLmFjdGlvbjtcbiAgICBpZiAoIXRoaXMudmlld2VkIHx8ICFhY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICAgIGZvckVhY2goZXZlbnQuY2hhbmdlZFRvdWNoZXMsIGZ1bmN0aW9uICh0b3VjaCkge1xuICAgICAgICBhc3NpZ24ocG9pbnRlcnNbdG91Y2guaWRlbnRpZmllcl0gfHwge30sIGdldFBvaW50ZXIodG91Y2gsIHRydWUpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ24ocG9pbnRlcnNbZXZlbnQucG9pbnRlcklkIHx8IDBdIHx8IHt9LCBnZXRQb2ludGVyKGV2ZW50LCB0cnVlKSk7XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlKGV2ZW50KTtcbiAgfSxcbiAgcG9pbnRlcnVwOiBmdW5jdGlvbiBwb2ludGVydXAoZXZlbnQpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIGFjdGlvbiA9IHRoaXMuYWN0aW9uLFxuICAgICAgcG9pbnRlcnMgPSB0aGlzLnBvaW50ZXJzO1xuICAgIHZhciBwb2ludGVyO1xuICAgIGlmIChldmVudC5jaGFuZ2VkVG91Y2hlcykge1xuICAgICAgZm9yRWFjaChldmVudC5jaGFuZ2VkVG91Y2hlcywgZnVuY3Rpb24gKHRvdWNoKSB7XG4gICAgICAgIHBvaW50ZXIgPSBwb2ludGVyc1t0b3VjaC5pZGVudGlmaWVyXTtcbiAgICAgICAgZGVsZXRlIHBvaW50ZXJzW3RvdWNoLmlkZW50aWZpZXJdO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ZXIgPSBwb2ludGVyc1tldmVudC5wb2ludGVySWQgfHwgMF07XG4gICAgICBkZWxldGUgcG9pbnRlcnNbZXZlbnQucG9pbnRlcklkIHx8IDBdO1xuICAgIH1cbiAgICBpZiAoIWFjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24gJiYgKGFjdGlvbiA9PT0gQUNUSU9OX01PVkUgfHwgYWN0aW9uID09PSBBQ1RJT05fWk9PTSkpIHtcbiAgICAgIGFkZENsYXNzKHRoaXMuaW1hZ2UsIENMQVNTX1RSQU5TSVRJT04pO1xuICAgIH1cbiAgICB0aGlzLmFjdGlvbiA9IGZhbHNlO1xuXG4gICAgLy8gRW11bGF0ZSBjbGljayBhbmQgZG91YmxlIGNsaWNrIGluIHRvdWNoIGRldmljZXMgdG8gc3VwcG9ydCBiYWNrZHJvcCBhbmQgaW1hZ2Ugem9vbWluZyAoIzIxMCkuXG4gICAgaWYgKElTX1RPVUNIX0RFVklDRSAmJiBhY3Rpb24gIT09IEFDVElPTl9aT09NICYmIHBvaW50ZXIgJiYgRGF0ZS5ub3coKSAtIHBvaW50ZXIudGltZVN0YW1wIDwgNTAwKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jbGlja0NhbnZhc1RpbWVvdXQpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZG91YmxlQ2xpY2tJbWFnZVRpbWVvdXQpO1xuICAgICAgaWYgKG9wdGlvbnMudG9nZ2xlT25EYmxjbGljayAmJiB0aGlzLnZpZXdlZCAmJiBldmVudC50YXJnZXQgPT09IHRoaXMuaW1hZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuaW1hZ2VDbGlja2VkKSB7XG4gICAgICAgICAgdGhpcy5pbWFnZUNsaWNrZWQgPSBmYWxzZTtcblxuICAgICAgICAgIC8vIFRoaXMgdGltZW91dCB3aWxsIGJlIGNsZWFyZWQgbGF0ZXIgd2hlbiBhIG5hdGl2ZSBkYmxjbGljayBldmVudCBpcyB0cmlnZ2VyaW5nXG4gICAgICAgICAgdGhpcy5kb3VibGVDbGlja0ltYWdlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGlzcGF0Y2hFdmVudChfdGhpczIuaW1hZ2UsIEVWRU5UX0RCTENMSUNLLCB7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCA1MCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5pbWFnZUNsaWNrZWQgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gVGhlIGRlZmF1bHQgdGltaW5nIG9mIGEgZG91YmxlIGNsaWNrIGluIFdpbmRvd3MgaXMgNTAwIG1zXG4gICAgICAgICAgdGhpcy5kb3VibGVDbGlja0ltYWdlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMyLmltYWdlQ2xpY2tlZCA9IGZhbHNlO1xuICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW1hZ2VDbGlja2VkID0gZmFsc2U7XG4gICAgICAgIGlmIChvcHRpb25zLmJhY2tkcm9wICYmIG9wdGlvbnMuYmFja2Ryb3AgIT09ICdzdGF0aWMnICYmIGV2ZW50LnRhcmdldCA9PT0gdGhpcy5jYW52YXMpIHtcbiAgICAgICAgICAvLyBUaGlzIHRpbWVvdXQgd2lsbCBiZSBjbGVhcmVkIGxhdGVyIHdoZW4gYSBuYXRpdmUgY2xpY2sgZXZlbnQgaXMgdHJpZ2dlcmluZ1xuICAgICAgICAgIHRoaXMuY2xpY2tDYW52YXNUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkaXNwYXRjaEV2ZW50KF90aGlzMi5jYW52YXMsIEVWRU5UX0NMSUNLLCB7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCA1MCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHJlc2l6ZTogZnVuY3Rpb24gcmVzaXplKCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgIGlmICghdGhpcy5pc1Nob3duIHx8IHRoaXMuaGlkaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmZ1bGxlZCkge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgdGhpcy5pbml0Qm9keSgpO1xuICAgICAgdGhpcy5vcGVuKCk7XG4gICAgfVxuICAgIHRoaXMuaW5pdENvbnRhaW5lcigpO1xuICAgIHRoaXMuaW5pdFZpZXdlcigpO1xuICAgIHRoaXMucmVuZGVyVmlld2VyKCk7XG4gICAgdGhpcy5yZW5kZXJMaXN0KCk7XG4gICAgaWYgKHRoaXMudmlld2VkKSB7XG4gICAgICB0aGlzLmluaXRJbWFnZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5yZW5kZXJJbWFnZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnBsYXllZCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5mdWxsc2NyZWVuICYmIHRoaXMuZnVsbGVkICYmICEoZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQubW96RnVsbFNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQubXNGdWxsc2NyZWVuRWxlbWVudCkpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvckVhY2godGhpcy5wbGF5ZXIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ltZycpLCBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgICAgYWRkTGlzdGVuZXIoaW1hZ2UsIEVWRU5UX0xPQUQsIF90aGlzMy5sb2FkSW1hZ2UuYmluZChfdGhpczMpLCB7XG4gICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgZGlzcGF0Y2hFdmVudChpbWFnZSwgRVZFTlRfTE9BRCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIHdoZWVsOiBmdW5jdGlvbiB3aGVlbChldmVudCkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgIGlmICghdGhpcy52aWV3ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIC8vIExpbWl0IHdoZWVsIHNwZWVkIHRvIHByZXZlbnQgem9vbSB0b28gZmFzdFxuICAgIGlmICh0aGlzLndoZWVsaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMud2hlZWxpbmcgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXM0LndoZWVsaW5nID0gZmFsc2U7XG4gICAgfSwgNTApO1xuICAgIHZhciByYXRpbyA9IE51bWJlcih0aGlzLm9wdGlvbnMuem9vbVJhdGlvKSB8fCAwLjE7XG4gICAgdmFyIGRlbHRhID0gMTtcbiAgICBpZiAoZXZlbnQuZGVsdGFZKSB7XG4gICAgICBkZWx0YSA9IGV2ZW50LmRlbHRhWSA+IDAgPyAxIDogLTE7XG4gICAgfSBlbHNlIGlmIChldmVudC53aGVlbERlbHRhKSB7XG4gICAgICBkZWx0YSA9IC1ldmVudC53aGVlbERlbHRhIC8gMTIwO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQuZGV0YWlsKSB7XG4gICAgICBkZWx0YSA9IGV2ZW50LmRldGFpbCA+IDAgPyAxIDogLTE7XG4gICAgfVxuICAgIHRoaXMuem9vbSgtZGVsdGEgKiByYXRpbywgdHJ1ZSwgbnVsbCwgZXZlbnQpO1xuICB9XG59O1xuXG52YXIgbWV0aG9kcyA9IHtcbiAgLyoqIFNob3cgdGhlIHZpZXdlciAob25seSBhdmFpbGFibGUgaW4gbW9kYWwgbW9kZSlcbiAgICogQHBhcmFtIHtib29sZWFufSBbaW1tZWRpYXRlPWZhbHNlXSAtIEluZGljYXRlcyBpZiBzaG93IHRoZSB2aWV3ZXIgaW1tZWRpYXRlbHkgb3Igbm90LlxuICAgKiBAcmV0dXJucyB7Vmlld2VyfSB0aGlzXG4gICAqL1xuICBzaG93OiBmdW5jdGlvbiBzaG93KCkge1xuICAgIHZhciBpbW1lZGlhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAob3B0aW9ucy5pbmxpbmUgfHwgdGhpcy5zaG93aW5nIHx8IHRoaXMuaXNTaG93biB8fCB0aGlzLnNob3dpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmVhZHkpIHtcbiAgICAgIHRoaXMuYnVpbGQoKTtcbiAgICAgIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgICAgIHRoaXMuc2hvdyhpbW1lZGlhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuc2hvdykpIHtcbiAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX1NIT1csIG9wdGlvbnMuc2hvdywge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoRXZlbnQoZWxlbWVudCwgRVZFTlRfU0hPVykgPT09IGZhbHNlIHx8ICF0aGlzLnJlYWR5KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuaGlkaW5nKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb25pbmcuYWJvcnQoKTtcbiAgICB9XG4gICAgdGhpcy5zaG93aW5nID0gdHJ1ZTtcbiAgICB0aGlzLm9wZW4oKTtcbiAgICB2YXIgdmlld2VyID0gdGhpcy52aWV3ZXI7XG4gICAgcmVtb3ZlQ2xhc3Modmlld2VyLCBDTEFTU19ISURFKTtcbiAgICB2aWV3ZXIuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2RpYWxvZycpO1xuICAgIHZpZXdlci5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWxsZWRieScsIHRoaXMudGl0bGUuaWQpO1xuICAgIHZpZXdlci5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCB0cnVlKTtcbiAgICB2aWV3ZXIucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24gJiYgIWltbWVkaWF0ZSkge1xuICAgICAgdmFyIHNob3duID0gdGhpcy5zaG93bi5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy50cmFuc2l0aW9uaW5nID0ge1xuICAgICAgICBhYm9ydDogZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICAgICAgcmVtb3ZlTGlzdGVuZXIodmlld2VyLCBFVkVOVF9UUkFOU0lUSU9OX0VORCwgc2hvd24pO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKHZpZXdlciwgQ0xBU1NfSU4pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYWRkQ2xhc3Modmlld2VyLCBDTEFTU19UUkFOU0lUSU9OKTtcblxuICAgICAgLy8gRm9yY2UgcmVmbG93IHRvIGVuYWJsZSBDU1MzIHRyYW5zaXRpb25cbiAgICAgIHZpZXdlci5pbml0aWFsT2Zmc2V0V2lkdGggPSB2aWV3ZXIub2Zmc2V0V2lkdGg7XG4gICAgICBhZGRMaXN0ZW5lcih2aWV3ZXIsIEVWRU5UX1RSQU5TSVRJT05fRU5ELCBzaG93biwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGFkZENsYXNzKHZpZXdlciwgQ0xBU1NfSU4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGRDbGFzcyh2aWV3ZXIsIENMQVNTX0lOKTtcbiAgICAgIHRoaXMuc2hvd24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBIaWRlIHRoZSB2aWV3ZXIgKG9ubHkgYXZhaWxhYmxlIGluIG1vZGFsIG1vZGUpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ltbWVkaWF0ZT1mYWxzZV0gLSBJbmRpY2F0ZXMgaWYgaGlkZSB0aGUgdmlld2VyIGltbWVkaWF0ZWx5IG9yIG5vdC5cbiAgICogQHJldHVybnMge1ZpZXdlcn0gdGhpc1xuICAgKi9cbiAgaGlkZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBpbW1lZGlhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAob3B0aW9ucy5pbmxpbmUgfHwgdGhpcy5oaWRpbmcgfHwgISh0aGlzLmlzU2hvd24gfHwgdGhpcy5zaG93aW5nKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuaGlkZSkpIHtcbiAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX0hJREUsIG9wdGlvbnMuaGlkZSwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoRXZlbnQoZWxlbWVudCwgRVZFTlRfSElERSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuc2hvd2luZykge1xuICAgICAgdGhpcy50cmFuc2l0aW9uaW5nLmFib3J0KCk7XG4gICAgfVxuICAgIHRoaXMuaGlkaW5nID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5wbGF5ZWQpIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy52aWV3aW5nKSB7XG4gICAgICB0aGlzLnZpZXdpbmcuYWJvcnQoKTtcbiAgICB9XG4gICAgdmFyIHZpZXdlciA9IHRoaXMudmlld2VyLFxuICAgICAgaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgIHZhciBoaWRlSW1tZWRpYXRlbHkgPSBmdW5jdGlvbiBoaWRlSW1tZWRpYXRlbHkoKSB7XG4gICAgICByZW1vdmVDbGFzcyh2aWV3ZXIsIENMQVNTX0lOKTtcbiAgICAgIF90aGlzLmhpZGRlbigpO1xuICAgIH07XG4gICAgaWYgKG9wdGlvbnMudHJhbnNpdGlvbiAmJiAhaW1tZWRpYXRlKSB7XG4gICAgICB2YXIgb25WaWV3ZXJUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gb25WaWV3ZXJUcmFuc2l0aW9uRW5kKGV2ZW50KSB7XG4gICAgICAgIC8vIElnbm9yZSBhbGwgcHJvcGFnYXRpbmcgYHRyYW5zaXRpb25lbmRgIGV2ZW50cyAoIzI3NSkuXG4gICAgICAgIGlmIChldmVudCAmJiBldmVudC50YXJnZXQgPT09IHZpZXdlcikge1xuICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKHZpZXdlciwgRVZFTlRfVFJBTlNJVElPTl9FTkQsIG9uVmlld2VyVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgICAgX3RoaXMuaGlkZGVuKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgb25JbWFnZVRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiBvbkltYWdlVHJhbnNpdGlvbkVuZCgpIHtcbiAgICAgICAgLy8gSW4gY2FzZSBvZiBzaG93IHRoZSB2aWV3ZXIgYnkgYHZpZXdlci5zaG93KHRydWUpYCBwcmV2aW91c2x5ICgjNDA3KS5cbiAgICAgICAgaWYgKGhhc0NsYXNzKHZpZXdlciwgQ0xBU1NfVFJBTlNJVElPTikpIHtcbiAgICAgICAgICBhZGRMaXN0ZW5lcih2aWV3ZXIsIEVWRU5UX1RSQU5TSVRJT05fRU5ELCBvblZpZXdlclRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKHZpZXdlciwgQ0xBU1NfSU4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhpZGVJbW1lZGlhdGVseSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy50cmFuc2l0aW9uaW5nID0ge1xuICAgICAgICBhYm9ydDogZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICAgICAgaWYgKF90aGlzLnZpZXdlZCAmJiBoYXNDbGFzcyhpbWFnZSwgQ0xBU1NfVFJBTlNJVElPTikpIHtcbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKGltYWdlLCBFVkVOVF9UUkFOU0lUSU9OX0VORCwgb25JbWFnZVRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2xhc3Modmlld2VyLCBDTEFTU19UUkFOU0lUSU9OKSkge1xuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIodmlld2VyLCBFVkVOVF9UUkFOU0lUSU9OX0VORCwgb25WaWV3ZXJUcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIEluIGNhc2Ugb2YgaGlkaW5nIHRoZSB2aWV3ZXIgd2hlbiBob2xkaW5nIG9uIHRoZSBpbWFnZSAoIzI1NSksXG4gICAgICAvLyBub3RlIHRoYXQgdGhlIGBDTEFTU19UUkFOU0lUSU9OYCBjbGFzcyB3aWxsIGJlIHJlbW92ZWQgb24gcG9pbnRlciBkb3duLlxuICAgICAgaWYgKHRoaXMudmlld2VkICYmIGhhc0NsYXNzKGltYWdlLCBDTEFTU19UUkFOU0lUSU9OKSkge1xuICAgICAgICBhZGRMaXN0ZW5lcihpbWFnZSwgRVZFTlRfVFJBTlNJVElPTl9FTkQsIG9uSW1hZ2VUcmFuc2l0aW9uRW5kLCB7XG4gICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy56b29tVG8oMCwgZmFsc2UsIG51bGwsIG51bGwsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25JbWFnZVRyYW5zaXRpb25FbmQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaGlkZUltbWVkaWF0ZWx5KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogVmlldyBvbmUgb2YgdGhlIGltYWdlcyB3aXRoIGltYWdlJ3MgaW5kZXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBpbWFnZSB0byB2aWV3LlxuICAgKiBAcmV0dXJucyB7Vmlld2VyfSB0aGlzXG4gICAqL1xuICB2aWV3OiBmdW5jdGlvbiB2aWV3KCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5vcHRpb25zLmluaXRpYWxWaWV3SW5kZXg7XG4gICAgaW5kZXggPSBOdW1iZXIoaW5kZXgpIHx8IDA7XG4gICAgaWYgKHRoaXMuaGlkaW5nIHx8IHRoaXMucGxheWVkIHx8IGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmxlbmd0aCB8fCB0aGlzLnZpZXdlZCAmJiBpbmRleCA9PT0gdGhpcy5pbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc1Nob3duKSB7XG4gICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICByZXR1cm4gdGhpcy5zaG93KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnZpZXdpbmcpIHtcbiAgICAgIHRoaXMudmlld2luZy5hYm9ydCgpO1xuICAgIH1cbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICB0aXRsZSA9IHRoaXMudGl0bGUsXG4gICAgICBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICB2YXIgaXRlbSA9IHRoaXMuaXRlbXNbaW5kZXhdO1xuICAgIHZhciBpbWcgPSBpdGVtLnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xuICAgIHZhciB1cmwgPSBnZXREYXRhKGltZywgJ29yaWdpbmFsVXJsJyk7XG4gICAgdmFyIGFsdCA9IGltZy5nZXRBdHRyaWJ1dGUoJ2FsdCcpO1xuICAgIHZhciBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgIGZvckVhY2gob3B0aW9ucy5pbmhlcml0ZWRBdHRyaWJ1dGVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gaW1nLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBpbWFnZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGltYWdlLnNyYyA9IHVybDtcbiAgICBpbWFnZS5hbHQgPSBhbHQ7XG4gICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy52aWV3KSkge1xuICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfVklFVywgb3B0aW9ucy52aWV3LCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2hFdmVudChlbGVtZW50LCBFVkVOVF9WSUVXLCB7XG4gICAgICBvcmlnaW5hbEltYWdlOiB0aGlzLmltYWdlc1tpbmRleF0sXG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBpbWFnZTogaW1hZ2VcbiAgICB9KSA9PT0gZmFsc2UgfHwgIXRoaXMuaXNTaG93biB8fCB0aGlzLmhpZGluZyB8fCB0aGlzLnBsYXllZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBhY3RpdmVJdGVtID0gdGhpcy5pdGVtc1t0aGlzLmluZGV4XTtcbiAgICBpZiAoYWN0aXZlSXRlbSkge1xuICAgICAgcmVtb3ZlQ2xhc3MoYWN0aXZlSXRlbSwgQ0xBU1NfQUNUSVZFKTtcbiAgICAgIGFjdGl2ZUl0ZW0ucmVtb3ZlQXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJyk7XG4gICAgfVxuICAgIGFkZENsYXNzKGl0ZW0sIENMQVNTX0FDVElWRSk7XG4gICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKTtcbiAgICBpZiAob3B0aW9ucy5mb2N1cykge1xuICAgICAgaXRlbS5mb2N1cygpO1xuICAgIH1cbiAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgdGhpcy52aWV3ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5pbWFnZURhdGEgPSB7fTtcbiAgICBhZGRDbGFzcyhpbWFnZSwgQ0xBU1NfSU5WSVNJQkxFKTtcbiAgICBpZiAob3B0aW9ucy5sb2FkaW5nKSB7XG4gICAgICBhZGRDbGFzcyhjYW52YXMsIENMQVNTX0xPQURJTkcpO1xuICAgIH1cbiAgICBjYW52YXMuaW5uZXJIVE1MID0gJyc7XG4gICAgY2FudmFzLmFwcGVuZENoaWxkKGltYWdlKTtcblxuICAgIC8vIENlbnRlciBjdXJyZW50IGl0ZW1cbiAgICB0aGlzLnJlbmRlckxpc3QoKTtcblxuICAgIC8vIENsZWFyIHRpdGxlXG4gICAgdGl0bGUuaW5uZXJIVE1MID0gJyc7XG5cbiAgICAvLyBHZW5lcmF0ZSB0aXRsZSBhZnRlciB2aWV3ZWRcbiAgICB2YXIgb25WaWV3ZWQgPSBmdW5jdGlvbiBvblZpZXdlZCgpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBfdGhpczIuaW1hZ2VEYXRhO1xuICAgICAgdmFyIHJlbmRlciA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy50aXRsZSkgPyBvcHRpb25zLnRpdGxlWzFdIDogb3B0aW9ucy50aXRsZTtcbiAgICAgIHRpdGxlLmlubmVySFRNTCA9IGVzY2FwZUhUTUxFbnRpdGllcyhpc0Z1bmN0aW9uKHJlbmRlcikgPyByZW5kZXIuY2FsbChfdGhpczIsIGltYWdlLCBpbWFnZURhdGEpIDogXCJcIi5jb25jYXQoYWx0LCBcIiAoXCIpLmNvbmNhdChpbWFnZURhdGEubmF0dXJhbFdpZHRoLCBcIiBcXHhENyBcIikuY29uY2F0KGltYWdlRGF0YS5uYXR1cmFsSGVpZ2h0LCBcIilcIikpO1xuICAgIH07XG4gICAgdmFyIG9uTG9hZDtcbiAgICB2YXIgb25FcnJvcjtcbiAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9WSUVXRUQsIG9uVmlld2VkLCB7XG4gICAgICBvbmNlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy52aWV3aW5nID0ge1xuICAgICAgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9WSUVXRUQsIG9uVmlld2VkKTtcbiAgICAgICAgaWYgKGltYWdlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgaWYgKF90aGlzMi5pbWFnZVJlbmRlcmluZykge1xuICAgICAgICAgICAgX3RoaXMyLmltYWdlUmVuZGVyaW5nLmFib3J0KCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChfdGhpczIuaW1hZ2VJbml0aWFsaXppbmcpIHtcbiAgICAgICAgICAgIF90aGlzMi5pbWFnZUluaXRpYWxpemluZy5hYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDYW5jZWwgZG93bmxvYWQgdG8gc2F2ZSBiYW5kd2lkdGguXG4gICAgICAgICAgaW1hZ2Uuc3JjID0gJyc7XG4gICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoaW1hZ2UsIEVWRU5UX0xPQUQsIG9uTG9hZCk7XG4gICAgICAgICAgaWYgKF90aGlzMi50aW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMyLnRpbWVvdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGltYWdlLmNvbXBsZXRlKSB7XG4gICAgICB0aGlzLmxvYWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkTGlzdGVuZXIoaW1hZ2UsIEVWRU5UX0xPQUQsIG9uTG9hZCA9IGZ1bmN0aW9uIG9uTG9hZCgpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoaW1hZ2UsIEVWRU5UX0VSUk9SLCBvbkVycm9yKTtcbiAgICAgICAgX3RoaXMyLmxvYWQoKTtcbiAgICAgIH0sIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBhZGRMaXN0ZW5lcihpbWFnZSwgRVZFTlRfRVJST1IsIG9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKCkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihpbWFnZSwgRVZFTlRfTE9BRCwgb25Mb2FkKTtcbiAgICAgICAgaWYgKF90aGlzMi50aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzMi50aW1lb3V0KTtcbiAgICAgICAgICBfdGhpczIudGltZW91dCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZUNsYXNzKGltYWdlLCBDTEFTU19JTlZJU0lCTEUpO1xuICAgICAgICBpZiAob3B0aW9ucy5sb2FkaW5nKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoX3RoaXMyLmNhbnZhcywgQ0xBU1NfTE9BRElORyk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIHRoZSBpbWFnZSB2aXNpYmxlIGlmIGl0IGZhaWxzIHRvIGxvYWQgd2l0aGluIDFzXG4gICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVtb3ZlQ2xhc3MoaW1hZ2UsIENMQVNTX0lOVklTSUJMRSk7XG4gICAgICAgIF90aGlzMi50aW1lb3V0ID0gZmFsc2U7XG4gICAgICB9LCAxMDAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBWaWV3IHRoZSBwcmV2aW91cyBpbWFnZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtsb29wPWZhbHNlXSAtIEluZGljYXRlIGlmIHZpZXcgdGhlIGxhc3Qgb25lXG4gICAqIHdoZW4gaXQgaXMgdGhlIGZpcnN0IG9uZSBhdCBwcmVzZW50LlxuICAgKiBAcmV0dXJucyB7Vmlld2VyfSB0aGlzXG4gICAqL1xuICBwcmV2OiBmdW5jdGlvbiBwcmV2KCkge1xuICAgIHZhciBsb29wID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4IC0gMTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICBpbmRleCA9IGxvb3AgPyB0aGlzLmxlbmd0aCAtIDEgOiAwO1xuICAgIH1cbiAgICB0aGlzLnZpZXcoaW5kZXgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogVmlldyB0aGUgbmV4dCBpbWFnZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtsb29wPWZhbHNlXSAtIEluZGljYXRlIGlmIHZpZXcgdGhlIGZpcnN0IG9uZVxuICAgKiB3aGVuIGl0IGlzIHRoZSBsYXN0IG9uZSBhdCBwcmVzZW50LlxuICAgKiBAcmV0dXJucyB7Vmlld2VyfSB0aGlzXG4gICAqL1xuICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgIHZhciBsb29wID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICB2YXIgbWF4SW5kZXggPSB0aGlzLmxlbmd0aCAtIDE7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCArIDE7XG4gICAgaWYgKGluZGV4ID4gbWF4SW5kZXgpIHtcbiAgICAgIGluZGV4ID0gbG9vcCA/IDAgOiBtYXhJbmRleDtcbiAgICB9XG4gICAgdGhpcy52aWV3KGluZGV4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLyoqXG4gICAqIE1vdmUgdGhlIGltYWdlIHdpdGggcmVsYXRpdmUgb2Zmc2V0cy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgbW92aW5nIGRpc3RhbmNlIGluIHRoZSBob3Jpem9udGFsIGRpcmVjdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt5PXhdIFRoZSBtb3ZpbmcgZGlzdGFuY2UgaW4gdGhlIHZlcnRpY2FsIGRpcmVjdGlvbi5cbiAgICogQHJldHVybnMge1ZpZXdlcn0gdGhpc1xuICAgKi9cbiAgbW92ZTogZnVuY3Rpb24gbW92ZSh4KSB7XG4gICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHg7XG4gICAgdmFyIGltYWdlRGF0YSA9IHRoaXMuaW1hZ2VEYXRhO1xuICAgIHRoaXMubW92ZVRvKGlzVW5kZWZpbmVkKHgpID8geCA6IGltYWdlRGF0YS54ICsgTnVtYmVyKHgpLCBpc1VuZGVmaW5lZCh5KSA/IHkgOiBpbWFnZURhdGEueSArIE51bWJlcih5KSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBpbWFnZSB0byBhbiBhYnNvbHV0ZSBwb2ludC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgbmV3IHBvc2l0aW9uIGluIHRoZSBob3Jpem9udGFsIGRpcmVjdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt5PXhdIC0gVGhlIG5ldyBwb3NpdGlvbiBpbiB0aGUgdmVydGljYWwgZGlyZWN0aW9uLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBbX29yaWdpbmFsRXZlbnQ9bnVsbF0gLSBUaGUgb3JpZ2luYWwgZXZlbnQgaWYgYW55LlxuICAgKiBAcmV0dXJucyB7Vmlld2VyfSB0aGlzXG4gICAqL1xuICBtb3ZlVG86IGZ1bmN0aW9uIG1vdmVUbyh4KSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHg7XG4gICAgdmFyIF9vcmlnaW5hbEV2ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIGltYWdlRGF0YSA9IHRoaXMuaW1hZ2VEYXRhO1xuICAgIHggPSBOdW1iZXIoeCk7XG4gICAgeSA9IE51bWJlcih5KTtcbiAgICBpZiAodGhpcy52aWV3ZWQgJiYgIXRoaXMucGxheWVkICYmIG9wdGlvbnMubW92YWJsZSkge1xuICAgICAgdmFyIG9sZFggPSBpbWFnZURhdGEueDtcbiAgICAgIHZhciBvbGRZID0gaW1hZ2VEYXRhLnk7XG4gICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgaWYgKGlzTnVtYmVyKHgpKSB7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IG9sZFg7XG4gICAgICB9XG4gICAgICBpZiAoaXNOdW1iZXIoeSkpIHtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5ID0gb2xkWTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMubW92ZSkpIHtcbiAgICAgICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9NT1ZFLCBvcHRpb25zLm1vdmUsIHtcbiAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzcGF0Y2hFdmVudChlbGVtZW50LCBFVkVOVF9NT1ZFLCB7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIG9sZFg6IG9sZFgsXG4gICAgICAgICAgb2xkWTogb2xkWSxcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBfb3JpZ2luYWxFdmVudFxuICAgICAgICB9KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpbWFnZURhdGEueCA9IHg7XG4gICAgICAgIGltYWdlRGF0YS55ID0geTtcbiAgICAgICAgaW1hZ2VEYXRhLmxlZnQgPSB4O1xuICAgICAgICBpbWFnZURhdGEudG9wID0geTtcbiAgICAgICAgdGhpcy5tb3ZpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlbmRlckltYWdlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczMubW92aW5nID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5tb3ZlZCkpIHtcbiAgICAgICAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX01PVkVELCBvcHRpb25zLm1vdmVkLCB7XG4gICAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaXNwYXRjaEV2ZW50KGVsZW1lbnQsIEVWRU5UX01PVkVELCB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIG9sZFg6IG9sZFgsXG4gICAgICAgICAgICBvbGRZOiBvbGRZLFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogX29yaWdpbmFsRXZlbnRcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBSb3RhdGUgdGhlIGltYWdlIHdpdGggYSByZWxhdGl2ZSBkZWdyZWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWdyZWUgLSBUaGUgcm90YXRlIGRlZ3JlZS5cbiAgICogQHJldHVybnMge1ZpZXdlcn0gdGhpc1xuICAgKi9cbiAgcm90YXRlOiBmdW5jdGlvbiByb3RhdGUoZGVncmVlKSB7XG4gICAgdGhpcy5yb3RhdGVUbygodGhpcy5pbWFnZURhdGEucm90YXRlIHx8IDApICsgTnVtYmVyKGRlZ3JlZSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogUm90YXRlIHRoZSBpbWFnZSB0byBhbiBhYnNvbHV0ZSBkZWdyZWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWdyZWUgLSBUaGUgcm90YXRlIGRlZ3JlZS5cbiAgICogQHJldHVybnMge1ZpZXdlcn0gdGhpc1xuICAgKi9cbiAgcm90YXRlVG86IGZ1bmN0aW9uIHJvdGF0ZVRvKGRlZ3JlZSkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIGltYWdlRGF0YSA9IHRoaXMuaW1hZ2VEYXRhO1xuICAgIGRlZ3JlZSA9IE51bWJlcihkZWdyZWUpO1xuICAgIGlmIChpc051bWJlcihkZWdyZWUpICYmIHRoaXMudmlld2VkICYmICF0aGlzLnBsYXllZCAmJiBvcHRpb25zLnJvdGF0YWJsZSkge1xuICAgICAgdmFyIG9sZERlZ3JlZSA9IGltYWdlRGF0YS5yb3RhdGU7XG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLnJvdGF0ZSkpIHtcbiAgICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfUk9UQVRFLCBvcHRpb25zLnJvdGF0ZSwge1xuICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoZGlzcGF0Y2hFdmVudChlbGVtZW50LCBFVkVOVF9ST1RBVEUsIHtcbiAgICAgICAgZGVncmVlOiBkZWdyZWUsXG4gICAgICAgIG9sZERlZ3JlZTogb2xkRGVncmVlXG4gICAgICB9KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpbWFnZURhdGEucm90YXRlID0gZGVncmVlO1xuICAgICAgdGhpcy5yb3RhdGluZyA9IHRydWU7XG4gICAgICB0aGlzLnJlbmRlckltYWdlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM0LnJvdGF0aW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMucm90YXRlZCkpIHtcbiAgICAgICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9ST1RBVEVELCBvcHRpb25zLnJvdGF0ZWQsIHtcbiAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaEV2ZW50KGVsZW1lbnQsIEVWRU5UX1JPVEFURUQsIHtcbiAgICAgICAgICBkZWdyZWU6IGRlZ3JlZSxcbiAgICAgICAgICBvbGREZWdyZWU6IG9sZERlZ3JlZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBTY2FsZSB0aGUgaW1hZ2Ugb24gdGhlIHgtYXhpcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWCAtIFRoZSBzY2FsZSByYXRpbyBvbiB0aGUgeC1heGlzLlxuICAgKiBAcmV0dXJucyB7Vmlld2VyfSB0aGlzXG4gICAqL1xuICBzY2FsZVg6IGZ1bmN0aW9uIHNjYWxlWChfc2NhbGVYKSB7XG4gICAgdGhpcy5zY2FsZShfc2NhbGVYLCB0aGlzLmltYWdlRGF0YS5zY2FsZVkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogU2NhbGUgdGhlIGltYWdlIG9uIHRoZSB5LWF4aXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVkgLSBUaGUgc2NhbGUgcmF0aW8gb24gdGhlIHktYXhpcy5cbiAgICogQHJldHVybnMge1ZpZXdlcn0gdGhpc1xuICAgKi9cbiAgc2NhbGVZOiBmdW5jdGlvbiBzY2FsZVkoX3NjYWxlWSkge1xuICAgIHRoaXMuc2NhbGUodGhpcy5pbWFnZURhdGEuc2NhbGVYLCBfc2NhbGVZKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLyoqXG4gICAqIFNjYWxlIHRoZSBpbWFnZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWCAtIFRoZSBzY2FsZSByYXRpbyBvbiB0aGUgeC1heGlzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlWT1zY2FsZVhdIC0gVGhlIHNjYWxlIHJhdGlvIG9uIHRoZSB5LWF4aXMuXG4gICAqIEByZXR1cm5zIHtWaWV3ZXJ9IHRoaXNcbiAgICovXG4gIHNjYWxlOiBmdW5jdGlvbiBzY2FsZShzY2FsZVgpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgICB2YXIgc2NhbGVZID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBzY2FsZVg7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgaW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGE7XG4gICAgc2NhbGVYID0gTnVtYmVyKHNjYWxlWCk7XG4gICAgc2NhbGVZID0gTnVtYmVyKHNjYWxlWSk7XG4gICAgaWYgKHRoaXMudmlld2VkICYmICF0aGlzLnBsYXllZCAmJiBvcHRpb25zLnNjYWxhYmxlKSB7XG4gICAgICB2YXIgb2xkU2NhbGVYID0gaW1hZ2VEYXRhLnNjYWxlWDtcbiAgICAgIHZhciBvbGRTY2FsZVkgPSBpbWFnZURhdGEuc2NhbGVZO1xuICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIGlmIChpc051bWJlcihzY2FsZVgpKSB7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGVYID0gb2xkU2NhbGVYO1xuICAgICAgfVxuICAgICAgaWYgKGlzTnVtYmVyKHNjYWxlWSkpIHtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2FsZVkgPSBvbGRTY2FsZVk7XG4gICAgICB9XG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLnNjYWxlKSkge1xuICAgICAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX1NDQUxFLCBvcHRpb25zLnNjYWxlLCB7XG4gICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3BhdGNoRXZlbnQoZWxlbWVudCwgRVZFTlRfU0NBTEUsIHtcbiAgICAgICAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICAgICAgICBzY2FsZVk6IHNjYWxlWSxcbiAgICAgICAgICBvbGRTY2FsZVg6IG9sZFNjYWxlWCxcbiAgICAgICAgICBvbGRTY2FsZVk6IG9sZFNjYWxlWVxuICAgICAgICB9KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpbWFnZURhdGEuc2NhbGVYID0gc2NhbGVYO1xuICAgICAgICBpbWFnZURhdGEuc2NhbGVZID0gc2NhbGVZO1xuICAgICAgICB0aGlzLnNjYWxpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlbmRlckltYWdlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczUuc2NhbGluZyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuc2NhbGVkKSkge1xuICAgICAgICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfU0NBTEVELCBvcHRpb25zLnNjYWxlZCwge1xuICAgICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGlzcGF0Y2hFdmVudChlbGVtZW50LCBFVkVOVF9TQ0FMRUQsIHtcbiAgICAgICAgICAgIHNjYWxlWDogc2NhbGVYLFxuICAgICAgICAgICAgc2NhbGVZOiBzY2FsZVksXG4gICAgICAgICAgICBvbGRTY2FsZVg6IG9sZFNjYWxlWCxcbiAgICAgICAgICAgIG9sZFNjYWxlWTogb2xkU2NhbGVZXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogWm9vbSB0aGUgaW1hZ2Ugd2l0aCBhIHJlbGF0aXZlIHJhdGlvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmF0aW8gLSBUaGUgdGFyZ2V0IHJhdGlvLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzaG93VG9vbHRpcD1mYWxzZV0gLSBJbmRpY2F0ZXMgd2hldGhlciB0byBzaG93IHRoZSB0b29sdGlwLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Bpdm90XSAtIFRoZSBwaXZvdCBwb2ludCBjb29yZGluYXRlIGZvciB6b29taW5nLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBbX29yaWdpbmFsRXZlbnQ9bnVsbF0gLSBUaGUgb3JpZ2luYWwgZXZlbnQgaWYgYW55LlxuICAgKiBAcmV0dXJucyB7Vmlld2VyfSB0aGlzXG4gICAqL1xuICB6b29tOiBmdW5jdGlvbiB6b29tKHJhdGlvKSB7XG4gICAgdmFyIHNob3dUb29sdGlwID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICB2YXIgcGl2b3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgdmFyIF9vcmlnaW5hbEV2ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuICAgIHZhciBpbWFnZURhdGEgPSB0aGlzLmltYWdlRGF0YTtcbiAgICByYXRpbyA9IE51bWJlcihyYXRpbyk7XG4gICAgaWYgKHJhdGlvIDwgMCkge1xuICAgICAgcmF0aW8gPSAxIC8gKDEgLSByYXRpbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhdGlvID0gMSArIHJhdGlvO1xuICAgIH1cbiAgICB0aGlzLnpvb21UbyhpbWFnZURhdGEud2lkdGggKiByYXRpbyAvIGltYWdlRGF0YS5uYXR1cmFsV2lkdGgsIHNob3dUb29sdGlwLCBwaXZvdCwgX29yaWdpbmFsRXZlbnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogWm9vbSB0aGUgaW1hZ2UgdG8gYW4gYWJzb2x1dGUgcmF0aW8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYXRpbyAtIFRoZSB0YXJnZXQgcmF0aW8uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Nob3dUb29sdGlwXSAtIEluZGljYXRlcyB3aGV0aGVyIHRvIHNob3cgdGhlIHRvb2x0aXAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGl2b3RdIC0gVGhlIHBpdm90IHBvaW50IGNvb3JkaW5hdGUgZm9yIHpvb21pbmcuXG4gICAqIEBwYXJhbSB7RXZlbnR9IFtfb3JpZ2luYWxFdmVudD1udWxsXSAtIFRoZSBvcmlnaW5hbCBldmVudCBpZiBhbnkuXG4gICAqIEBwYXJhbSB7RXZlbnR9IFtfem9vbWFibGU9ZmFsc2VdIC0gSW5kaWNhdGVzIGlmIHRoZSBjdXJyZW50IHpvb20gaXMgYXZhaWxhYmxlIG9yIG5vdC5cbiAgICogQHJldHVybnMge1ZpZXdlcn0gdGhpc1xuICAgKi9cbiAgem9vbVRvOiBmdW5jdGlvbiB6b29tVG8ocmF0aW8pIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcbiAgICB2YXIgc2hvd1Rvb2x0aXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIHZhciBwaXZvdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICB2YXIgX29yaWdpbmFsRXZlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG4gICAgdmFyIF96b29tYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgcG9pbnRlcnMgPSB0aGlzLnBvaW50ZXJzLFxuICAgICAgaW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGE7XG4gICAgdmFyIHggPSBpbWFnZURhdGEueCxcbiAgICAgIHkgPSBpbWFnZURhdGEueSxcbiAgICAgIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgIG5hdHVyYWxXaWR0aCA9IGltYWdlRGF0YS5uYXR1cmFsV2lkdGgsXG4gICAgICBuYXR1cmFsSGVpZ2h0ID0gaW1hZ2VEYXRhLm5hdHVyYWxIZWlnaHQ7XG4gICAgcmF0aW8gPSBNYXRoLm1heCgwLCByYXRpbyk7XG4gICAgaWYgKGlzTnVtYmVyKHJhdGlvKSAmJiB0aGlzLnZpZXdlZCAmJiAhdGhpcy5wbGF5ZWQgJiYgKF96b29tYWJsZSB8fCBvcHRpb25zLnpvb21hYmxlKSkge1xuICAgICAgaWYgKCFfem9vbWFibGUpIHtcbiAgICAgICAgdmFyIG1pblpvb21SYXRpbyA9IE1hdGgubWF4KDAuMDEsIG9wdGlvbnMubWluWm9vbVJhdGlvKTtcbiAgICAgICAgdmFyIG1heFpvb21SYXRpbyA9IE1hdGgubWluKDEwMCwgb3B0aW9ucy5tYXhab29tUmF0aW8pO1xuICAgICAgICByYXRpbyA9IE1hdGgubWluKE1hdGgubWF4KHJhdGlvLCBtaW5ab29tUmF0aW8pLCBtYXhab29tUmF0aW8pO1xuICAgICAgfVxuICAgICAgaWYgKF9vcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoX29yaWdpbmFsRXZlbnQudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3doZWVsJzpcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnpvb21SYXRpbyA+PSAwLjA1NSAmJiByYXRpbyA+IDAuOTUgJiYgcmF0aW8gPCAxLjA1KSB7XG4gICAgICAgICAgICAgIHJhdGlvID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3BvaW50ZXJtb3ZlJzpcbiAgICAgICAgICBjYXNlICd0b3VjaG1vdmUnOlxuICAgICAgICAgIGNhc2UgJ21vdXNlbW92ZSc6XG4gICAgICAgICAgICBpZiAocmF0aW8gPiAwLjk5ICYmIHJhdGlvIDwgMS4wMSkge1xuICAgICAgICAgICAgICByYXRpbyA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG5ld1dpZHRoID0gbmF0dXJhbFdpZHRoICogcmF0aW87XG4gICAgICB2YXIgbmV3SGVpZ2h0ID0gbmF0dXJhbEhlaWdodCAqIHJhdGlvO1xuICAgICAgdmFyIG9mZnNldFdpZHRoID0gbmV3V2lkdGggLSB3aWR0aDtcbiAgICAgIHZhciBvZmZzZXRIZWlnaHQgPSBuZXdIZWlnaHQgLSBoZWlnaHQ7XG4gICAgICB2YXIgb2xkUmF0aW8gPSBpbWFnZURhdGEucmF0aW87XG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLnpvb20pKSB7XG4gICAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX1pPT00sIG9wdGlvbnMuem9vbSwge1xuICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoZGlzcGF0Y2hFdmVudChlbGVtZW50LCBFVkVOVF9aT09NLCB7XG4gICAgICAgIHJhdGlvOiByYXRpbyxcbiAgICAgICAgb2xkUmF0aW86IG9sZFJhdGlvLFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBfb3JpZ2luYWxFdmVudFxuICAgICAgfSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy56b29taW5nID0gdHJ1ZTtcbiAgICAgIGlmIChfb3JpZ2luYWxFdmVudCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gZ2V0T2Zmc2V0KHRoaXMudmlld2VyKTtcbiAgICAgICAgdmFyIGNlbnRlciA9IHBvaW50ZXJzICYmIE9iamVjdC5rZXlzKHBvaW50ZXJzKS5sZW5ndGggPiAwID8gZ2V0UG9pbnRlcnNDZW50ZXIocG9pbnRlcnMpIDoge1xuICAgICAgICAgIHBhZ2VYOiBfb3JpZ2luYWxFdmVudC5wYWdlWCxcbiAgICAgICAgICBwYWdlWTogX29yaWdpbmFsRXZlbnQucGFnZVlcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBab29tIGZyb20gdGhlIHRyaWdnZXJpbmcgcG9pbnQgb2YgdGhlIGV2ZW50XG4gICAgICAgIGltYWdlRGF0YS54IC09IG9mZnNldFdpZHRoICogKChjZW50ZXIucGFnZVggLSBvZmZzZXQubGVmdCAtIHgpIC8gd2lkdGgpO1xuICAgICAgICBpbWFnZURhdGEueSAtPSBvZmZzZXRIZWlnaHQgKiAoKGNlbnRlci5wYWdlWSAtIG9mZnNldC50b3AgLSB5KSAvIGhlaWdodCk7XG4gICAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocGl2b3QpICYmIGlzTnVtYmVyKHBpdm90LngpICYmIGlzTnVtYmVyKHBpdm90LnkpKSB7XG4gICAgICAgIGltYWdlRGF0YS54IC09IG9mZnNldFdpZHRoICogKChwaXZvdC54IC0geCkgLyB3aWR0aCk7XG4gICAgICAgIGltYWdlRGF0YS55IC09IG9mZnNldEhlaWdodCAqICgocGl2b3QueSAtIHkpIC8gaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFpvb20gZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBpbWFnZVxuICAgICAgICBpbWFnZURhdGEueCAtPSBvZmZzZXRXaWR0aCAvIDI7XG4gICAgICAgIGltYWdlRGF0YS55IC09IG9mZnNldEhlaWdodCAvIDI7XG4gICAgICB9XG4gICAgICBpbWFnZURhdGEubGVmdCA9IGltYWdlRGF0YS54O1xuICAgICAgaW1hZ2VEYXRhLnRvcCA9IGltYWdlRGF0YS55O1xuICAgICAgaW1hZ2VEYXRhLndpZHRoID0gbmV3V2lkdGg7XG4gICAgICBpbWFnZURhdGEuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgaW1hZ2VEYXRhLm9sZFJhdGlvID0gb2xkUmF0aW87XG4gICAgICBpbWFnZURhdGEucmF0aW8gPSByYXRpbztcbiAgICAgIHRoaXMucmVuZGVySW1hZ2UoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczYuem9vbWluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLnpvb21lZCkpIHtcbiAgICAgICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9aT09NRUQsIG9wdGlvbnMuem9vbWVkLCB7XG4gICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZGlzcGF0Y2hFdmVudChlbGVtZW50LCBFVkVOVF9aT09NRUQsIHtcbiAgICAgICAgICByYXRpbzogcmF0aW8sXG4gICAgICAgICAgb2xkUmF0aW86IG9sZFJhdGlvLFxuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IF9vcmlnaW5hbEV2ZW50XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHNob3dUb29sdGlwKSB7XG4gICAgICAgIHRoaXMudG9vbHRpcCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLyoqXG4gICAqIFBsYXkgdGhlIGltYWdlc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW58RnVsbHNjcmVlbk9wdGlvbnN9IFtmdWxsc2NyZWVuPWZhbHNlXSAtIEluZGljYXRlIGlmIHJlcXVlc3QgZnVsbHNjcmVlbiBvciBub3QuXG4gICAqIEByZXR1cm5zIHtWaWV3ZXJ9IHRoaXNcbiAgICovXG4gIHBsYXk6IGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgdmFyIF90aGlzNyA9IHRoaXM7XG4gICAgdmFyIGZ1bGxzY3JlZW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIGlmICghdGhpcy5pc1Nob3duIHx8IHRoaXMucGxheWVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMucGxheSkpIHtcbiAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX1BMQVksIG9wdGlvbnMucGxheSwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoRXZlbnQoZWxlbWVudCwgRVZFTlRfUExBWSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIHBsYXllciA9IHRoaXMucGxheWVyO1xuICAgIHZhciBvbkxvYWQgPSB0aGlzLmxvYWRJbWFnZS5iaW5kKHRoaXMpO1xuICAgIHZhciBsaXN0ID0gW107XG4gICAgdmFyIHRvdGFsID0gMDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHRoaXMucGxheWVkID0gdHJ1ZTtcbiAgICB0aGlzLm9uTG9hZFdoZW5QbGF5ID0gb25Mb2FkO1xuICAgIGlmIChmdWxsc2NyZWVuKSB7XG4gICAgICB0aGlzLnJlcXVlc3RGdWxsc2NyZWVuKGZ1bGxzY3JlZW4pO1xuICAgIH1cbiAgICBhZGRDbGFzcyhwbGF5ZXIsIENMQVNTX1NIT1cpO1xuICAgIGZvckVhY2godGhpcy5pdGVtcywgZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgIHZhciBpbWcgPSBpdGVtLnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xuICAgICAgdmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICBpbWFnZS5zcmMgPSBnZXREYXRhKGltZywgJ29yaWdpbmFsVXJsJyk7XG4gICAgICBpbWFnZS5hbHQgPSBpbWcuZ2V0QXR0cmlidXRlKCdhbHQnKTtcbiAgICAgIGltYWdlLnJlZmVycmVyUG9saWN5ID0gaW1nLnJlZmVycmVyUG9saWN5O1xuICAgICAgdG90YWwgKz0gMTtcbiAgICAgIGFkZENsYXNzKGltYWdlLCBDTEFTU19GQURFKTtcbiAgICAgIHRvZ2dsZUNsYXNzKGltYWdlLCBDTEFTU19UUkFOU0lUSU9OLCBvcHRpb25zLnRyYW5zaXRpb24pO1xuICAgICAgaWYgKGhhc0NsYXNzKGl0ZW0sIENMQVNTX0FDVElWRSkpIHtcbiAgICAgICAgYWRkQ2xhc3MoaW1hZ2UsIENMQVNTX0lOKTtcbiAgICAgICAgaW5kZXggPSBpO1xuICAgICAgfVxuICAgICAgbGlzdC5wdXNoKGltYWdlKTtcbiAgICAgIGFkZExpc3RlbmVyKGltYWdlLCBFVkVOVF9MT0FELCBvbkxvYWQsIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBwbGF5ZXIuYXBwZW5kQ2hpbGQoaW1hZ2UpO1xuICAgIH0pO1xuICAgIGlmIChpc051bWJlcihvcHRpb25zLmludGVydmFsKSAmJiBvcHRpb25zLmludGVydmFsID4gMCkge1xuICAgICAgdmFyIHByZXYgPSBmdW5jdGlvbiBwcmV2KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXM3LnBsYXlpbmcudGltZW91dCk7XG4gICAgICAgIHJlbW92ZUNsYXNzKGxpc3RbaW5kZXhdLCBDTEFTU19JTik7XG4gICAgICAgIGluZGV4IC09IDE7XG4gICAgICAgIGluZGV4ID0gaW5kZXggPj0gMCA/IGluZGV4IDogdG90YWwgLSAxO1xuICAgICAgICBhZGRDbGFzcyhsaXN0W2luZGV4XSwgQ0xBU1NfSU4pO1xuICAgICAgICBfdGhpczcucGxheWluZy50aW1lb3V0ID0gc2V0VGltZW91dChwcmV2LCBvcHRpb25zLmludGVydmFsKTtcbiAgICAgIH07XG4gICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChfdGhpczcucGxheWluZy50aW1lb3V0KTtcbiAgICAgICAgcmVtb3ZlQ2xhc3MobGlzdFtpbmRleF0sIENMQVNTX0lOKTtcbiAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgaW5kZXggPSBpbmRleCA8IHRvdGFsID8gaW5kZXggOiAwO1xuICAgICAgICBhZGRDbGFzcyhsaXN0W2luZGV4XSwgQ0xBU1NfSU4pO1xuICAgICAgICBfdGhpczcucGxheWluZy50aW1lb3V0ID0gc2V0VGltZW91dChuZXh0LCBvcHRpb25zLmludGVydmFsKTtcbiAgICAgIH07XG4gICAgICBpZiAodG90YWwgPiAxKSB7XG4gICAgICAgIHRoaXMucGxheWluZyA9IHtcbiAgICAgICAgICBwcmV2OiBwcmV2LFxuICAgICAgICAgIG5leHQ6IG5leHQsXG4gICAgICAgICAgdGltZW91dDogc2V0VGltZW91dChuZXh0LCBvcHRpb25zLmludGVydmFsKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gU3RvcCBwbGF5XG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgdmFyIF90aGlzOCA9IHRoaXM7XG4gICAgaWYgKCF0aGlzLnBsYXllZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLnN0b3ApKSB7XG4gICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9TVE9QLCBvcHRpb25zLnN0b3AsIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaEV2ZW50KGVsZW1lbnQsIEVWRU5UX1NUT1ApID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBwbGF5ZXIgPSB0aGlzLnBsYXllcjtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5wbGF5aW5nLnRpbWVvdXQpO1xuICAgIHRoaXMucGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMucGxheWVkID0gZmFsc2U7XG4gICAgZm9yRWFjaChwbGF5ZXIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ltZycpLCBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGltYWdlLCBFVkVOVF9MT0FELCBfdGhpczgub25Mb2FkV2hlblBsYXkpO1xuICAgIH0pO1xuICAgIHJlbW92ZUNsYXNzKHBsYXllciwgQ0xBU1NfU0hPVyk7XG4gICAgcGxheWVyLmlubmVySFRNTCA9ICcnO1xuICAgIHRoaXMuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gRW50ZXIgbW9kYWwgbW9kZSAob25seSBhdmFpbGFibGUgaW4gaW5saW5lIG1vZGUpXG4gIGZ1bGw6IGZ1bmN0aW9uIGZ1bGwoKSB7XG4gICAgdmFyIF90aGlzOSA9IHRoaXM7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICB2aWV3ZXIgPSB0aGlzLnZpZXdlcixcbiAgICAgIGltYWdlID0gdGhpcy5pbWFnZSxcbiAgICAgIGxpc3QgPSB0aGlzLmxpc3Q7XG4gICAgaWYgKCF0aGlzLmlzU2hvd24gfHwgdGhpcy5wbGF5ZWQgfHwgdGhpcy5mdWxsZWQgfHwgIW9wdGlvbnMuaW5saW5lKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5mdWxsZWQgPSB0cnVlO1xuICAgIHRoaXMub3BlbigpO1xuICAgIGFkZENsYXNzKHRoaXMuYnV0dG9uLCBDTEFTU19GVUxMU0NSRUVOX0VYSVQpO1xuICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24pIHtcbiAgICAgIHJlbW92ZUNsYXNzKGxpc3QsIENMQVNTX1RSQU5TSVRJT04pO1xuICAgICAgaWYgKHRoaXMudmlld2VkKSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKGltYWdlLCBDTEFTU19UUkFOU0lUSU9OKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYWRkQ2xhc3Modmlld2VyLCBDTEFTU19GSVhFRCk7XG4gICAgdmlld2VyLnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcbiAgICB2aWV3ZXIuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsbGVkYnknLCB0aGlzLnRpdGxlLmlkKTtcbiAgICB2aWV3ZXIuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgdHJ1ZSk7XG4gICAgdmlld2VyLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICBzZXRTdHlsZSh2aWV3ZXIsIHtcbiAgICAgIHpJbmRleDogb3B0aW9ucy56SW5kZXhcbiAgICB9KTtcbiAgICBpZiAob3B0aW9ucy5mb2N1cykge1xuICAgICAgdGhpcy5lbmZvcmNlRm9jdXMoKTtcbiAgICB9XG4gICAgdGhpcy5pbml0Q29udGFpbmVyKCk7XG4gICAgdGhpcy52aWV3ZXJEYXRhID0gYXNzaWduKHt9LCB0aGlzLmNvbnRhaW5lckRhdGEpO1xuICAgIHRoaXMucmVuZGVyTGlzdCgpO1xuICAgIGlmICh0aGlzLnZpZXdlZCkge1xuICAgICAgdGhpcy5pbml0SW1hZ2UoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczkucmVuZGVySW1hZ2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBhZGRDbGFzcyhpbWFnZSwgQ0xBU1NfVFJBTlNJVElPTik7XG4gICAgICAgICAgICAgIGFkZENsYXNzKGxpc3QsIENMQVNTX1RSQU5TSVRJT04pO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gRXhpdCBtb2RhbCBtb2RlIChvbmx5IGF2YWlsYWJsZSBpbiBpbmxpbmUgbW9kZSlcbiAgZXhpdDogZnVuY3Rpb24gZXhpdCgpIHtcbiAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICB2aWV3ZXIgPSB0aGlzLnZpZXdlcixcbiAgICAgIGltYWdlID0gdGhpcy5pbWFnZSxcbiAgICAgIGxpc3QgPSB0aGlzLmxpc3Q7XG4gICAgaWYgKCF0aGlzLmlzU2hvd24gfHwgdGhpcy5wbGF5ZWQgfHwgIXRoaXMuZnVsbGVkIHx8ICFvcHRpb25zLmlubGluZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMuZnVsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5jbG9zZSgpO1xuICAgIHJlbW92ZUNsYXNzKHRoaXMuYnV0dG9uLCBDTEFTU19GVUxMU0NSRUVOX0VYSVQpO1xuICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24pIHtcbiAgICAgIHJlbW92ZUNsYXNzKGxpc3QsIENMQVNTX1RSQU5TSVRJT04pO1xuICAgICAgaWYgKHRoaXMudmlld2VkKSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKGltYWdlLCBDTEFTU19UUkFOU0lUSU9OKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZm9jdXMpIHtcbiAgICAgIHRoaXMuY2xlYXJFbmZvcmNlRm9jdXMoKTtcbiAgICB9XG4gICAgdmlld2VyLnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpO1xuICAgIHZpZXdlci5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbGFiZWxsZWRieScpO1xuICAgIHZpZXdlci5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnKTtcbiAgICByZW1vdmVDbGFzcyh2aWV3ZXIsIENMQVNTX0ZJWEVEKTtcbiAgICBzZXRTdHlsZSh2aWV3ZXIsIHtcbiAgICAgIHpJbmRleDogb3B0aW9ucy56SW5kZXhJbmxpbmVcbiAgICB9KTtcbiAgICB0aGlzLnZpZXdlckRhdGEgPSBhc3NpZ24oe30sIHRoaXMucGFyZW50RGF0YSk7XG4gICAgdGhpcy5yZW5kZXJWaWV3ZXIoKTtcbiAgICB0aGlzLnJlbmRlckxpc3QoKTtcbiAgICBpZiAodGhpcy52aWV3ZWQpIHtcbiAgICAgIHRoaXMuaW5pdEltYWdlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMxMC5yZW5kZXJJbWFnZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGFkZENsYXNzKGltYWdlLCBDTEFTU19UUkFOU0lUSU9OKTtcbiAgICAgICAgICAgICAgYWRkQ2xhc3MobGlzdCwgQ0xBU1NfVFJBTlNJVElPTik7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBTaG93IHRoZSBjdXJyZW50IHJhdGlvIG9mIHRoZSBpbWFnZSB3aXRoIHBlcmNlbnRhZ2VcbiAgdG9vbHRpcDogZnVuY3Rpb24gdG9vbHRpcCgpIHtcbiAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICB0b29sdGlwQm94ID0gdGhpcy50b29sdGlwQm94LFxuICAgICAgaW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGE7XG4gICAgaWYgKCF0aGlzLnZpZXdlZCB8fCB0aGlzLnBsYXllZCB8fCAhb3B0aW9ucy50b29sdGlwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9vbHRpcEJveC50ZXh0Q29udGVudCA9IFwiXCIuY29uY2F0KE1hdGgucm91bmQoaW1hZ2VEYXRhLnJhdGlvICogMTAwKSwgXCIlXCIpO1xuICAgIGlmICghdGhpcy50b29sdGlwcGluZykge1xuICAgICAgaWYgKG9wdGlvbnMudHJhbnNpdGlvbikge1xuICAgICAgICBpZiAodGhpcy5mYWRpbmcpIHtcbiAgICAgICAgICBkaXNwYXRjaEV2ZW50KHRvb2x0aXBCb3gsIEVWRU5UX1RSQU5TSVRJT05fRU5EKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRDbGFzcyh0b29sdGlwQm94LCBDTEFTU19TSE9XKTtcbiAgICAgICAgYWRkQ2xhc3ModG9vbHRpcEJveCwgQ0xBU1NfRkFERSk7XG4gICAgICAgIGFkZENsYXNzKHRvb2x0aXBCb3gsIENMQVNTX1RSQU5TSVRJT04pO1xuICAgICAgICB0b29sdGlwQm94LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcblxuICAgICAgICAvLyBGb3JjZSByZWZsb3cgdG8gZW5hYmxlIENTUzMgdHJhbnNpdGlvblxuICAgICAgICB0b29sdGlwQm94LmluaXRpYWxPZmZzZXRXaWR0aCA9IHRvb2x0aXBCb3gub2Zmc2V0V2lkdGg7XG4gICAgICAgIGFkZENsYXNzKHRvb2x0aXBCb3gsIENMQVNTX0lOKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZENsYXNzKHRvb2x0aXBCb3gsIENMQVNTX1NIT1cpO1xuICAgICAgICB0b29sdGlwQm94LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudG9vbHRpcHBpbmcpO1xuICAgIH1cbiAgICB0aGlzLnRvb2x0aXBwaW5nID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uKSB7XG4gICAgICAgIGFkZExpc3RlbmVyKHRvb2x0aXBCb3gsIEVWRU5UX1RSQU5TSVRJT05fRU5ELCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModG9vbHRpcEJveCwgQ0xBU1NfU0hPVyk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModG9vbHRpcEJveCwgQ0xBU1NfRkFERSk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModG9vbHRpcEJveCwgQ0xBU1NfVFJBTlNJVElPTik7XG4gICAgICAgICAgdG9vbHRpcEJveC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XG4gICAgICAgICAgX3RoaXMxMS5mYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgfSwge1xuICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbW92ZUNsYXNzKHRvb2x0aXBCb3gsIENMQVNTX0lOKTtcbiAgICAgICAgX3RoaXMxMS5mYWRpbmcgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlQ2xhc3ModG9vbHRpcEJveCwgQ0xBU1NfU0hPVyk7XG4gICAgICAgIHRvb2x0aXBCb3guc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICAgICAgfVxuICAgICAgX3RoaXMxMS50b29sdGlwcGluZyA9IGZhbHNlO1xuICAgIH0sIDEwMDApO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogVG9nZ2xlIHRoZSBpbWFnZSBzaXplIGJldHdlZW4gaXRzIGN1cnJlbnQgc2l6ZSBhbmQgbmF0dXJhbCBzaXplXG4gICAqIEBwYXJhbSB7RXZlbnR9IFtfb3JpZ2luYWxFdmVudD1udWxsXSAtIFRoZSBvcmlnaW5hbCBldmVudCBpZiBhbnkuXG4gICAqIEByZXR1cm5zIHtWaWV3ZXJ9IHRoaXNcbiAgICovXG4gIHRvZ2dsZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgIHZhciBfb3JpZ2luYWxFdmVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICBpZiAodGhpcy5pbWFnZURhdGEucmF0aW8gPT09IDEpIHtcbiAgICAgIHRoaXMuem9vbVRvKHRoaXMuaW1hZ2VEYXRhLm9sZFJhdGlvLCB0cnVlLCBudWxsLCBfb3JpZ2luYWxFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuem9vbVRvKDEsIHRydWUsIG51bGwsIF9vcmlnaW5hbEV2ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIFJlc2V0IHRoZSBpbWFnZSB0byBpdHMgaW5pdGlhbCBzdGF0ZVxuICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgaWYgKHRoaXMudmlld2VkICYmICF0aGlzLnBsYXllZCkge1xuICAgICAgdGhpcy5pbWFnZURhdGEgPSBhc3NpZ24oe30sIHRoaXMuaW5pdGlhbEltYWdlRGF0YSk7XG4gICAgICB0aGlzLnJlbmRlckltYWdlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBVcGRhdGUgdmlld2VyIHdoZW4gaW1hZ2VzIGNoYW5nZWRcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIF90aGlzMTIgPSB0aGlzO1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIGlzSW1nID0gdGhpcy5pc0ltZztcblxuICAgIC8vIERlc3Ryb3kgdmlld2VyIGlmIHRoZSB0YXJnZXQgaW1hZ2Ugd2FzIGRlbGV0ZWRcbiAgICBpZiAoaXNJbWcgJiYgIWVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICB2YXIgaW1hZ2VzID0gW107XG4gICAgZm9yRWFjaChpc0ltZyA/IFtlbGVtZW50XSA6IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW1nJyksIGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5maWx0ZXIpKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmZpbHRlci5jYWxsKF90aGlzMTIsIGltYWdlKSkge1xuICAgICAgICAgIGltYWdlcy5wdXNoKGltYWdlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfdGhpczEyLmdldEltYWdlVVJMKGltYWdlKSkge1xuICAgICAgICBpbWFnZXMucHVzaChpbWFnZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFpbWFnZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5pbWFnZXMgPSBpbWFnZXM7XG4gICAgdGhpcy5sZW5ndGggPSBpbWFnZXMubGVuZ3RoO1xuICAgIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgICB2YXIgY2hhbmdlZEluZGV4ZXMgPSBbXTtcbiAgICAgIGZvckVhY2godGhpcy5pdGVtcywgZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgdmFyIGltZyA9IGl0ZW0ucXVlcnlTZWxlY3RvcignaW1nJyk7XG4gICAgICAgIHZhciBpbWFnZSA9IGltYWdlc1tpXTtcbiAgICAgICAgaWYgKGltYWdlICYmIGltZykge1xuICAgICAgICAgIGlmIChpbWFnZS5zcmMgIT09IGltZy5zcmNcblxuICAgICAgICAgIC8vIFRpdGxlIGNoYW5nZWQgKCM0MDgpXG4gICAgICAgICAgfHwgaW1hZ2UuYWx0ICE9PSBpbWcuYWx0KSB7XG4gICAgICAgICAgICBjaGFuZ2VkSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGFuZ2VkSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHNldFN0eWxlKHRoaXMubGlzdCwge1xuICAgICAgICB3aWR0aDogJ2F1dG8nXG4gICAgICB9KTtcbiAgICAgIHRoaXMuaW5pdExpc3QoKTtcbiAgICAgIGlmICh0aGlzLmlzU2hvd24pIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHRoaXMudmlld2VkKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlZEluZGV4ID0gY2hhbmdlZEluZGV4ZXMuaW5kZXhPZih0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICB0aGlzLnZpZXdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB0aGlzLnZpZXcoTWF0aC5tYXgoTWF0aC5taW4odGhpcy5pbmRleCAtIGNoYW5nZWRJbmRleCwgdGhpcy5sZW5ndGggLSAxKSwgMCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGFjdGl2ZUl0ZW0gPSB0aGlzLml0ZW1zW3RoaXMuaW5kZXhdO1xuXG4gICAgICAgICAgICAgIC8vIFJlYWN0aXZhdGUgdGhlIGN1cnJlbnQgdmlld2luZyBpdGVtIGFmdGVyIHJlc2V0IHRoZSBsaXN0LlxuICAgICAgICAgICAgICBhZGRDbGFzcyhhY3RpdmVJdGVtLCBDTEFTU19BQ1RJVkUpO1xuICAgICAgICAgICAgICBhY3RpdmVJdGVtLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmltYWdlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLnZpZXdlZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAgIHRoaXMuaW1hZ2VEYXRhID0ge307XG4gICAgICAgICAgdGhpcy5jYW52YXMuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgdGhpcy50aXRsZS5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJ1aWxkKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBEZXN0cm95IHRoZSB2aWV3ZXJcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKCFlbGVtZW50W05BTUVTUEFDRV0pIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgaWYgKHRoaXMucmVhZHkpIHtcbiAgICAgIGlmICh0aGlzLnBsYXllZCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmlubGluZSkge1xuICAgICAgICBpZiAodGhpcy5mdWxsZWQpIHtcbiAgICAgICAgICB0aGlzLmV4aXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVuYmluZCgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzU2hvd24pIHtcbiAgICAgICAgaWYgKHRoaXMudmlld2luZykge1xuICAgICAgICAgIGlmICh0aGlzLmltYWdlUmVuZGVyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlUmVuZGVyaW5nLmFib3J0KCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmltYWdlSW5pdGlhbGl6aW5nKSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlSW5pdGlhbGl6aW5nLmFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhpZGluZykge1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvbmluZy5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGlkZGVuKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc2hvd2luZykge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25pbmcuYWJvcnQoKTtcbiAgICAgICAgdGhpcy5oaWRkZW4oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgICAgIHRoaXMudmlld2VyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy52aWV3ZXIpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pbmxpbmUpIHtcbiAgICAgIGlmICh0aGlzLmRlbGF5aW5nKSB7XG4gICAgICAgIHRoaXMuZGVsYXlpbmcuYWJvcnQoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pbml0aWFsaXppbmcpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXppbmcuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLmlubGluZSkge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfQ0xJQ0ssIHRoaXMub25TdGFydCk7XG4gICAgfVxuICAgIGVsZW1lbnRbTkFNRVNQQUNFXSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxudmFyIG90aGVycyA9IHtcbiAgZ2V0SW1hZ2VVUkw6IGZ1bmN0aW9uIGdldEltYWdlVVJMKGltYWdlKSB7XG4gICAgdmFyIHVybCA9IHRoaXMub3B0aW9ucy51cmw7XG4gICAgaWYgKGlzU3RyaW5nKHVybCkpIHtcbiAgICAgIHVybCA9IGltYWdlLmdldEF0dHJpYnV0ZSh1cmwpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih1cmwpKSB7XG4gICAgICB1cmwgPSB1cmwuY2FsbCh0aGlzLCBpbWFnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVybCA9ICcnO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xuICB9LFxuICBlbmZvcmNlRm9jdXM6IGZ1bmN0aW9uIGVuZm9yY2VGb2N1cygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuY2xlYXJFbmZvcmNlRm9jdXMoKTtcbiAgICBhZGRMaXN0ZW5lcihkb2N1bWVudCwgRVZFTlRfRk9DVVNJTiwgdGhpcy5vbkZvY3VzaW4gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciB2aWV3ZXIgPSBfdGhpcy52aWV3ZXI7XG4gICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgaWYgKHRhcmdldCA9PT0gZG9jdW1lbnQgfHwgdGFyZ2V0ID09PSB2aWV3ZXIgfHwgdmlld2VyLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHRhcmdldCkge1xuICAgICAgICAvLyBBdm9pZCBjb25mbGljdHMgd2l0aCBvdGhlciBtb2RhbHMgKCM0NzQsICM1NDApXG4gICAgICAgIGlmICh0YXJnZXQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpICE9PSBudWxsIHx8IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnKSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnRFbGVtZW50O1xuICAgICAgfVxuICAgICAgdmlld2VyLmZvY3VzKCk7XG4gICAgfSk7XG4gIH0sXG4gIGNsZWFyRW5mb3JjZUZvY3VzOiBmdW5jdGlvbiBjbGVhckVuZm9yY2VGb2N1cygpIHtcbiAgICBpZiAodGhpcy5vbkZvY3VzaW4pIHtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGRvY3VtZW50LCBFVkVOVF9GT0NVU0lOLCB0aGlzLm9uRm9jdXNpbik7XG4gICAgICB0aGlzLm9uRm9jdXNpbiA9IG51bGw7XG4gICAgfVxuICB9LFxuICBvcGVuOiBmdW5jdGlvbiBvcGVuKCkge1xuICAgIHZhciBib2R5ID0gdGhpcy5ib2R5O1xuICAgIGFkZENsYXNzKGJvZHksIENMQVNTX09QRU4pO1xuICAgIGlmICh0aGlzLnNjcm9sbGJhcldpZHRoID4gMCkge1xuICAgICAgYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBcIlwiLmNvbmNhdCh0aGlzLnNjcm9sbGJhcldpZHRoICsgKHBhcnNlRmxvYXQodGhpcy5pbml0aWFsQm9keUNvbXB1dGVkUGFkZGluZ1JpZ2h0KSB8fCAwKSwgXCJweFwiKTtcbiAgICB9XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICB2YXIgYm9keSA9IHRoaXMuYm9keTtcbiAgICByZW1vdmVDbGFzcyhib2R5LCBDTEFTU19PUEVOKTtcbiAgICBpZiAodGhpcy5zY3JvbGxiYXJXaWR0aCA+IDApIHtcbiAgICAgIGJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0ID0gdGhpcy5pbml0aWFsQm9keVBhZGRpbmdSaWdodDtcbiAgICB9XG4gIH0sXG4gIHNob3duOiBmdW5jdGlvbiBzaG93bigpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICB2aWV3ZXIgPSB0aGlzLnZpZXdlcjtcbiAgICB0aGlzLmZ1bGxlZCA9IHRydWU7XG4gICAgdGhpcy5pc1Nob3duID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlcigpO1xuICAgIHRoaXMuYmluZCgpO1xuICAgIHRoaXMuc2hvd2luZyA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLmZvY3VzKSB7XG4gICAgICB2aWV3ZXIuZm9jdXMoKTtcbiAgICAgIHRoaXMuZW5mb3JjZUZvY3VzKCk7XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuc2hvd24pKSB7XG4gICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9TSE9XTiwgb3B0aW9ucy5zaG93biwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoRXZlbnQoZWxlbWVudCwgRVZFTlRfU0hPV04pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZWFkeSAmJiB0aGlzLmlzU2hvd24gJiYgIXRoaXMuaGlkaW5nKSB7XG4gICAgICB0aGlzLnZpZXcodGhpcy5pbmRleCk7XG4gICAgfVxuICB9LFxuICBoaWRkZW46IGZ1bmN0aW9uIGhpZGRlbigpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICB2aWV3ZXIgPSB0aGlzLnZpZXdlcjtcbiAgICBpZiAob3B0aW9ucy5mdWN1cykge1xuICAgICAgdGhpcy5jbGVhckVuZm9yY2VGb2N1cygpO1xuICAgIH1cbiAgICB0aGlzLmNsb3NlKCk7XG4gICAgdGhpcy51bmJpbmQoKTtcbiAgICBhZGRDbGFzcyh2aWV3ZXIsIENMQVNTX0hJREUpO1xuICAgIHZpZXdlci5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcbiAgICB2aWV3ZXIucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWxhYmVsbGVkYnknKTtcbiAgICB2aWV3ZXIucmVtb3ZlQXR0cmlidXRlKCdhcmlhLW1vZGFsJyk7XG4gICAgdmlld2VyLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0cnVlKTtcbiAgICB0aGlzLnJlc2V0TGlzdCgpO1xuICAgIHRoaXMucmVzZXRJbWFnZSgpO1xuICAgIHRoaXMuZnVsbGVkID0gZmFsc2U7XG4gICAgdGhpcy52aWV3ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzU2hvd24gPSBmYWxzZTtcbiAgICB0aGlzLmhpZGluZyA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuaGlkZGVuKSkge1xuICAgICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9ISURERU4sIG9wdGlvbnMuaGlkZGVuLCB7XG4gICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRpc3BhdGNoRXZlbnQoZWxlbWVudCwgRVZFTlRfSElEREVOLCBudWxsLCB7XG4gICAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIHJlcXVlc3RGdWxsc2NyZWVuOiBmdW5jdGlvbiByZXF1ZXN0RnVsbHNjcmVlbihvcHRpb25zKSB7XG4gICAgdmFyIGRvY3VtZW50ID0gdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgaWYgKHRoaXMuZnVsbGVkICYmICEoZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQubW96RnVsbFNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQubXNGdWxsc2NyZWVuRWxlbWVudCkpIHtcbiAgICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgIC8vIEVsZW1lbnQucmVxdWVzdEZ1bGxzY3JlZW4oKVxuICAgICAgaWYgKGRvY3VtZW50RWxlbWVudC5yZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICAvLyBBdm9pZCBUeXBlRXJyb3Igd2hlbiBjb252ZXJ0IGBvcHRpb25zYCB0byBkaWN0aW9uYXJ5XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgICAgZG9jdW1lbnRFbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvY3VtZW50RWxlbWVudC5yZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudC53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICBkb2N1bWVudEVsZW1lbnQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oRWxlbWVudC5BTExPV19LRVlCT0FSRF9JTlBVVCk7XG4gICAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudC5tb3pSZXF1ZXN0RnVsbFNjcmVlbikge1xuICAgICAgICBkb2N1bWVudEVsZW1lbnQubW96UmVxdWVzdEZ1bGxTY3JlZW4oKTtcbiAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50Lm1zUmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgZG9jdW1lbnRFbGVtZW50Lm1zUmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGV4aXRGdWxsc2NyZWVuOiBmdW5jdGlvbiBleGl0RnVsbHNjcmVlbigpIHtcbiAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICBpZiAodGhpcy5mdWxsZWQgJiYgKGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IHx8IGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50IHx8IGRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbGVtZW50IHx8IGRvY3VtZW50Lm1zRnVsbHNjcmVlbkVsZW1lbnQpKSB7XG4gICAgICAvLyBEb2N1bWVudC5leGl0RnVsbHNjcmVlbigpXG4gICAgICBpZiAoZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbikge1xuICAgICAgICBkb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuKCk7XG4gICAgICB9IGVsc2UgaWYgKGRvY3VtZW50Lm1zRXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbigpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY2hhbmdlOiBmdW5jdGlvbiBjaGFuZ2UoZXZlbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIHBvaW50ZXJzID0gdGhpcy5wb2ludGVycztcbiAgICB2YXIgcG9pbnRlciA9IHBvaW50ZXJzW09iamVjdC5rZXlzKHBvaW50ZXJzKVswXV07XG5cbiAgICAvLyBJbiB0aGUgY2FzZSBvZiB0aGUgYHBvaW50ZXJzYCBvYmplY3QgaXMgZW1wdHkgKCM0MjEpXG4gICAgaWYgKCFwb2ludGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBvZmZzZXRYID0gcG9pbnRlci5lbmRYIC0gcG9pbnRlci5zdGFydFg7XG4gICAgdmFyIG9mZnNldFkgPSBwb2ludGVyLmVuZFkgLSBwb2ludGVyLnN0YXJ0WTtcbiAgICBzd2l0Y2ggKHRoaXMuYWN0aW9uKSB7XG4gICAgICAvLyBNb3ZlIHRoZSBjdXJyZW50IGltYWdlXG4gICAgICBjYXNlIEFDVElPTl9NT1ZFOlxuICAgICAgICBpZiAob2Zmc2V0WCAhPT0gMCB8fCBvZmZzZXRZICE9PSAwKSB7XG4gICAgICAgICAgdGhpcy5wb2ludGVyTW92ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMubW92ZShvZmZzZXRYLCBvZmZzZXRZLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIFpvb20gdGhlIGN1cnJlbnQgaW1hZ2VcbiAgICAgIGNhc2UgQUNUSU9OX1pPT006XG4gICAgICAgIHRoaXMuem9vbShnZXRNYXhab29tUmF0aW8ocG9pbnRlcnMpLCBmYWxzZSwgbnVsbCwgZXZlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQUNUSU9OX1NXSVRDSDpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMuYWN0aW9uID0gJ3N3aXRjaGVkJztcbiAgICAgICAgICB2YXIgYWJzb2x1dGVPZmZzZXRYID0gTWF0aC5hYnMob2Zmc2V0WCk7XG4gICAgICAgICAgaWYgKGFic29sdXRlT2Zmc2V0WCA+IDEgJiYgYWJzb2x1dGVPZmZzZXRYID4gTWF0aC5hYnMob2Zmc2V0WSkpIHtcbiAgICAgICAgICAgIC8vIEVtcHR5IGBwb2ludGVyc2AgYXMgYHRvdWNoZW5kYCBldmVudCB3aWxsIG5vdCBiZSBmaXJlZCBhZnRlciBzd2lwZWQgaW4gaU9TIGJyb3dzZXJzLlxuICAgICAgICAgICAgdGhpcy5wb2ludGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKG9mZnNldFggPiAxKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJldihvcHRpb25zLmxvb3ApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvZmZzZXRYIDwgLTEpIHtcbiAgICAgICAgICAgICAgdGhpcy5uZXh0KG9wdGlvbnMubG9vcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3ZlcnJpZGVcbiAgICBmb3JFYWNoKHBvaW50ZXJzLCBmdW5jdGlvbiAocCkge1xuICAgICAgcC5zdGFydFggPSBwLmVuZFg7XG4gICAgICBwLnN0YXJ0WSA9IHAuZW5kWTtcbiAgICB9KTtcbiAgfSxcbiAgaXNTd2l0Y2hhYmxlOiBmdW5jdGlvbiBpc1N3aXRjaGFibGUoKSB7XG4gICAgdmFyIGltYWdlRGF0YSA9IHRoaXMuaW1hZ2VEYXRhLFxuICAgICAgdmlld2VyRGF0YSA9IHRoaXMudmlld2VyRGF0YTtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPiAxICYmIGltYWdlRGF0YS54ID49IDAgJiYgaW1hZ2VEYXRhLnkgPj0gMCAmJiBpbWFnZURhdGEud2lkdGggPD0gdmlld2VyRGF0YS53aWR0aCAmJiBpbWFnZURhdGEuaGVpZ2h0IDw9IHZpZXdlckRhdGEuaGVpZ2h0O1xuICB9XG59O1xuXG52YXIgQW5vdGhlclZpZXdlciA9IFdJTkRPVy5WaWV3ZXI7XG52YXIgZ2V0VW5pcXVlSUQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZCArPSAxO1xuICAgIHJldHVybiBpZDtcbiAgfTtcbn0oLTEpO1xudmFyIFZpZXdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgVmlld2VyLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQgZm9yIHZpZXdpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gVmlld2VyKGVsZW1lbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZpZXdlcik7XG4gICAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZpcnN0IGFyZ3VtZW50IGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIGFuIGVsZW1lbnQuJyk7XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCBERUZBVUxUUywgaXNQbGFpbk9iamVjdChvcHRpb25zKSAmJiBvcHRpb25zKTtcbiAgICB0aGlzLmFjdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuZmFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5mdWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmhpZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuaW1hZ2VDbGlja2VkID0gZmFsc2U7XG4gICAgdGhpcy5pbWFnZURhdGEgPSB7fTtcbiAgICB0aGlzLmluZGV4ID0gdGhpcy5vcHRpb25zLmluaXRpYWxWaWV3SW5kZXg7XG4gICAgdGhpcy5pc0ltZyA9IGZhbHNlO1xuICAgIHRoaXMuaXNTaG93biA9IGZhbHNlO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLm1vdmluZyA9IGZhbHNlO1xuICAgIHRoaXMucGxheWVkID0gZmFsc2U7XG4gICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XG4gICAgdGhpcy5wb2ludGVycyA9IHt9O1xuICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgICB0aGlzLnJvdGF0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5zY2FsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5zaG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy50aW1lb3V0ID0gZmFsc2U7XG4gICAgdGhpcy50b29sdGlwcGluZyA9IGZhbHNlO1xuICAgIHRoaXMudmlld2VkID0gZmFsc2U7XG4gICAgdGhpcy52aWV3aW5nID0gZmFsc2U7XG4gICAgdGhpcy53aGVlbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuem9vbWluZyA9IGZhbHNlO1xuICAgIHRoaXMucG9pbnRlck1vdmVkID0gZmFsc2U7XG4gICAgdGhpcy5pZCA9IGdldFVuaXF1ZUlEKCk7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFZpZXdlciwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKGVsZW1lbnRbTkFNRVNQQUNFXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbGVtZW50W05BTUVTUEFDRV0gPSB0aGlzO1xuXG4gICAgICAvLyBUaGUgYGZvY3VzYCBvcHRpb24gcmVxdWlyZXMgdGhlIGBrZXlib2FyZGAgb3B0aW9uIHNldCB0byBgdHJ1ZWAuXG4gICAgICBpZiAob3B0aW9ucy5mb2N1cyAmJiAhb3B0aW9ucy5rZXlib2FyZCkge1xuICAgICAgICBvcHRpb25zLmZvY3VzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgaXNJbWcgPSBlbGVtZW50LmxvY2FsTmFtZSA9PT0gJ2ltZyc7XG4gICAgICB2YXIgaW1hZ2VzID0gW107XG4gICAgICBmb3JFYWNoKGlzSW1nID8gW2VsZW1lbnRdIDogZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbWcnKSwgZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuZmlsdGVyKSkge1xuICAgICAgICAgIGlmIChvcHRpb25zLmZpbHRlci5jYWxsKF90aGlzLCBpbWFnZSkpIHtcbiAgICAgICAgICAgIGltYWdlcy5wdXNoKGltYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoX3RoaXMuZ2V0SW1hZ2VVUkwoaW1hZ2UpKSB7XG4gICAgICAgICAgaW1hZ2VzLnB1c2goaW1hZ2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaXNJbWcgPSBpc0ltZztcbiAgICAgIHRoaXMubGVuZ3RoID0gaW1hZ2VzLmxlbmd0aDtcbiAgICAgIHRoaXMuaW1hZ2VzID0gaW1hZ2VzO1xuICAgICAgdGhpcy5pbml0Qm9keSgpO1xuXG4gICAgICAvLyBPdmVycmlkZSBgdHJhbnNpdGlvbmAgb3B0aW9uIGlmIGl0IGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgIGlmIChpc1VuZGVmaW5lZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KE5BTUVTUEFDRSkuc3R5bGUudHJhbnNpdGlvbikpIHtcbiAgICAgICAgb3B0aW9ucy50cmFuc2l0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5pbmxpbmUpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgdmFyIHByb2dyZXNzID0gZnVuY3Rpb24gcHJvZ3Jlc3MoKSB7XG4gICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICBpZiAoY291bnQgPT09IF90aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHRpbWVvdXQ7XG4gICAgICAgICAgICBfdGhpcy5pbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLmRlbGF5aW5nID0ge1xuICAgICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBidWlsZCBhc3luY2hyb25vdXNseSB0byBrZWVwIGB0aGlzLnZpZXdlcmAgaXMgYWNjZXNzaWJsZSBpbiBgcmVhZHlgIGV2ZW50IGhhbmRsZXIuXG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzLmRlbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgIF90aGlzLmJ1aWxkKCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6aW5nID0ge1xuICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgICAgICAgIGZvckVhY2goaW1hZ2VzLCBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgICAgICAgICAgaWYgKCFpbWFnZS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKGltYWdlLCBFVkVOVF9MT0FELCBwcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoaW1hZ2UsIEVWRU5UX0VSUk9SLCBwcm9ncmVzcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yRWFjaChpbWFnZXMsIGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgICAgIGlmIChpbWFnZS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgcHJvZ3Jlc3MoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9uTG9hZDtcbiAgICAgICAgICAgIHZhciBvbkVycm9yO1xuICAgICAgICAgICAgYWRkTGlzdGVuZXIoaW1hZ2UsIEVWRU5UX0xPQUQsIG9uTG9hZCA9IGZ1bmN0aW9uIG9uTG9hZCgpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoaW1hZ2UsIEVWRU5UX0VSUk9SLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgcHJvZ3Jlc3MoKTtcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhZGRMaXN0ZW5lcihpbWFnZSwgRVZFTlRfRVJST1IsIG9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKCkge1xuICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcihpbWFnZSwgRVZFTlRfTE9BRCwgb25Mb2FkKTtcbiAgICAgICAgICAgICAgcHJvZ3Jlc3MoKTtcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX0NMSUNLLCB0aGlzLm9uU3RhcnQgPSBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciB0YXJnZXQgPSBfcmVmLnRhcmdldDtcbiAgICAgICAgICBpZiAodGFyZ2V0LmxvY2FsTmFtZSA9PT0gJ2ltZycgJiYgKCFpc0Z1bmN0aW9uKG9wdGlvbnMuZmlsdGVyKSB8fCBvcHRpb25zLmZpbHRlci5jYWxsKF90aGlzLCB0YXJnZXQpKSkge1xuICAgICAgICAgICAgX3RoaXMudmlldyhfdGhpcy5pbWFnZXMuaW5kZXhPZih0YXJnZXQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJidWlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZCgpIHtcbiAgICAgIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgIHZhciB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gVEVNUExBVEU7XG4gICAgICB2YXIgdmlld2VyID0gdGVtcGxhdGUucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1jb250YWluZXJcIikpO1xuICAgICAgdmFyIHRpdGxlID0gdmlld2VyLnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItdGl0bGVcIikpO1xuICAgICAgdmFyIHRvb2xiYXIgPSB2aWV3ZXIucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoTkFNRVNQQUNFLCBcIi10b29sYmFyXCIpKTtcbiAgICAgIHZhciBuYXZiYXIgPSB2aWV3ZXIucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1uYXZiYXJcIikpO1xuICAgICAgdmFyIGJ1dHRvbiA9IHZpZXdlci5xdWVyeVNlbGVjdG9yKFwiLlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWJ1dHRvblwiKSk7XG4gICAgICB2YXIgY2FudmFzID0gdmlld2VyLnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItY2FudmFzXCIpKTtcbiAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgdGhpcy52aWV3ZXIgPSB2aWV3ZXI7XG4gICAgICB0aGlzLnRpdGxlID0gdGl0bGU7XG4gICAgICB0aGlzLnRvb2xiYXIgPSB0b29sYmFyO1xuICAgICAgdGhpcy5uYXZiYXIgPSBuYXZiYXI7XG4gICAgICB0aGlzLmJ1dHRvbiA9IGJ1dHRvbjtcbiAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgdGhpcy5mb290ZXIgPSB2aWV3ZXIucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1mb290ZXJcIikpO1xuICAgICAgdGhpcy50b29sdGlwQm94ID0gdmlld2VyLnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItdG9vbHRpcFwiKSk7XG4gICAgICB0aGlzLnBsYXllciA9IHZpZXdlci5xdWVyeVNlbGVjdG9yKFwiLlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLXBsYXllclwiKSk7XG4gICAgICB0aGlzLmxpc3QgPSB2aWV3ZXIucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1saXN0XCIpKTtcbiAgICAgIHZpZXdlci5pZCA9IFwiXCIuY29uY2F0KE5BTUVTUEFDRSkuY29uY2F0KHRoaXMuaWQpO1xuICAgICAgdGl0bGUuaWQgPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiVGl0bGVcIikuY29uY2F0KHRoaXMuaWQpO1xuICAgICAgYWRkQ2xhc3ModGl0bGUsICFvcHRpb25zLnRpdGxlID8gQ0xBU1NfSElERSA6IGdldFJlc3BvbnNpdmVDbGFzcyhBcnJheS5pc0FycmF5KG9wdGlvbnMudGl0bGUpID8gb3B0aW9ucy50aXRsZVswXSA6IG9wdGlvbnMudGl0bGUpKTtcbiAgICAgIGFkZENsYXNzKG5hdmJhciwgIW9wdGlvbnMubmF2YmFyID8gQ0xBU1NfSElERSA6IGdldFJlc3BvbnNpdmVDbGFzcyhvcHRpb25zLm5hdmJhcikpO1xuICAgICAgdG9nZ2xlQ2xhc3MoYnV0dG9uLCBDTEFTU19ISURFLCAhb3B0aW9ucy5idXR0b24pO1xuICAgICAgaWYgKG9wdGlvbnMua2V5Ym9hcmQpIHtcbiAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAwKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmJhY2tkcm9wKSB7XG4gICAgICAgIGFkZENsYXNzKHZpZXdlciwgXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1iYWNrZHJvcFwiKSk7XG4gICAgICAgIGlmICghb3B0aW9ucy5pbmxpbmUgJiYgb3B0aW9ucy5iYWNrZHJvcCAhPT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICBzZXREYXRhKGNhbnZhcywgREFUQV9BQ1RJT04sICdoaWRlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc1N0cmluZyhvcHRpb25zLmNsYXNzTmFtZSkgJiYgb3B0aW9ucy5jbGFzc05hbWUpIHtcbiAgICAgICAgLy8gSW4gY2FzZSB0aGVyZSBhcmUgbXVsdGlwbGUgY2xhc3MgbmFtZXNcbiAgICAgICAgb3B0aW9ucy5jbGFzc05hbWUuc3BsaXQoUkVHRVhQX1NQQUNFUykuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgYWRkQ2xhc3Modmlld2VyLCBjbGFzc05hbWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnRvb2xiYXIpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuICAgICAgICB2YXIgY3VzdG9tID0gaXNQbGFpbk9iamVjdChvcHRpb25zLnRvb2xiYXIpO1xuICAgICAgICB2YXIgem9vbUJ1dHRvbnMgPSBCVVRUT05TLnNsaWNlKDAsIDMpO1xuICAgICAgICB2YXIgcm90YXRlQnV0dG9ucyA9IEJVVFRPTlMuc2xpY2UoNywgOSk7XG4gICAgICAgIHZhciBzY2FsZUJ1dHRvbnMgPSBCVVRUT05TLnNsaWNlKDkpO1xuICAgICAgICBpZiAoIWN1c3RvbSkge1xuICAgICAgICAgIGFkZENsYXNzKHRvb2xiYXIsIGdldFJlc3BvbnNpdmVDbGFzcyhvcHRpb25zLnRvb2xiYXIpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3JFYWNoKGN1c3RvbSA/IG9wdGlvbnMudG9vbGJhciA6IEJVVFRPTlMsIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgZGVlcCA9IGN1c3RvbSAmJiBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IGN1c3RvbSA/IGh5cGhlbmF0ZShpbmRleCkgOiB2YWx1ZTtcbiAgICAgICAgICB2YXIgc2hvdyA9IGRlZXAgJiYgIWlzVW5kZWZpbmVkKHZhbHVlLnNob3cpID8gdmFsdWUuc2hvdyA6IHZhbHVlO1xuICAgICAgICAgIGlmICghc2hvdyB8fCAhb3B0aW9ucy56b29tYWJsZSAmJiB6b29tQnV0dG9ucy5pbmRleE9mKG5hbWUpICE9PSAtMSB8fCAhb3B0aW9ucy5yb3RhdGFibGUgJiYgcm90YXRlQnV0dG9ucy5pbmRleE9mKG5hbWUpICE9PSAtMSB8fCAhb3B0aW9ucy5zY2FsYWJsZSAmJiBzY2FsZUJ1dHRvbnMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNpemUgPSBkZWVwICYmICFpc1VuZGVmaW5lZCh2YWx1ZS5zaXplKSA/IHZhbHVlLnNpemUgOiB2YWx1ZTtcbiAgICAgICAgICB2YXIgY2xpY2sgPSBkZWVwICYmICFpc1VuZGVmaW5lZCh2YWx1ZS5jbGljaykgPyB2YWx1ZS5jbGljayA6IHZhbHVlO1xuICAgICAgICAgIHZhciBpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5rZXlib2FyZCkge1xuICAgICAgICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xuICAgICAgICAgIGFkZENsYXNzKGl0ZW0sIFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItXCIpLmNvbmNhdChuYW1lKSk7XG4gICAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGNsaWNrKSkge1xuICAgICAgICAgICAgc2V0RGF0YShpdGVtLCBEQVRBX0FDVElPTiwgbmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc051bWJlcihzaG93KSkge1xuICAgICAgICAgICAgYWRkQ2xhc3MoaXRlbSwgZ2V0UmVzcG9uc2l2ZUNsYXNzKHNob3cpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFsnc21hbGwnLCAnbGFyZ2UnXS5pbmRleE9mKHNpemUpICE9PSAtMSkge1xuICAgICAgICAgICAgYWRkQ2xhc3MoaXRlbSwgXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1cIikuY29uY2F0KHNpemUpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwbGF5Jykge1xuICAgICAgICAgICAgYWRkQ2xhc3MoaXRlbSwgXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1sYXJnZVwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGNsaWNrKSkge1xuICAgICAgICAgICAgYWRkTGlzdGVuZXIoaXRlbSwgRVZFTlRfQ0xJQ0ssIGNsaWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGlzdC5hcHBlbmRDaGlsZChpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRvb2xiYXIuYXBwZW5kQ2hpbGQobGlzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRDbGFzcyh0b29sYmFyLCBDTEFTU19ISURFKTtcbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW9ucy5yb3RhdGFibGUpIHtcbiAgICAgICAgdmFyIHJvdGF0ZXMgPSB0b29sYmFyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpW2NsYXNzKj1cInJvdGF0ZVwiXScpO1xuICAgICAgICBhZGRDbGFzcyhyb3RhdGVzLCBDTEFTU19JTlZJU0lCTEUpO1xuICAgICAgICBmb3JFYWNoKHJvdGF0ZXMsIGZ1bmN0aW9uIChyb3RhdGUpIHtcbiAgICAgICAgICB0b29sYmFyLmFwcGVuZENoaWxkKHJvdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuaW5saW5lKSB7XG4gICAgICAgIGFkZENsYXNzKGJ1dHRvbiwgQ0xBU1NfRlVMTFNDUkVFTik7XG4gICAgICAgIHNldFN0eWxlKHZpZXdlciwge1xuICAgICAgICAgIHpJbmRleDogb3B0aW9ucy56SW5kZXhJbmxpbmVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgICAgICAgIHNldFN0eWxlKHBhcmVudCwge1xuICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHZpZXdlciwgZWxlbWVudC5uZXh0U2libGluZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRDbGFzcyhidXR0b24sIENMQVNTX0NMT1NFKTtcbiAgICAgICAgYWRkQ2xhc3Modmlld2VyLCBDTEFTU19GSVhFRCk7XG4gICAgICAgIGFkZENsYXNzKHZpZXdlciwgQ0xBU1NfRkFERSk7XG4gICAgICAgIGFkZENsYXNzKHZpZXdlciwgQ0xBU1NfSElERSk7XG4gICAgICAgIHNldFN0eWxlKHZpZXdlciwge1xuICAgICAgICAgIHpJbmRleDogb3B0aW9ucy56SW5kZXhcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lcjtcbiAgICAgICAgaWYgKGlzU3RyaW5nKGNvbnRhaW5lcikpIHtcbiAgICAgICAgICBjb250YWluZXIgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3Rvcihjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgY29udGFpbmVyID0gdGhpcy5ib2R5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh2aWV3ZXIpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuaW5saW5lKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIHRoaXMuYmluZCgpO1xuICAgICAgICB0aGlzLmlzU2hvd24gPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLnJlYWR5KSkge1xuICAgICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9SRUFEWSwgb3B0aW9ucy5yZWFkeSwge1xuICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoZGlzcGF0Y2hFdmVudChlbGVtZW50LCBFVkVOVF9SRUFEWSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVhZHkgJiYgb3B0aW9ucy5pbmxpbmUpIHtcbiAgICAgICAgdGhpcy52aWV3KHRoaXMuaW5kZXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbm8gY29uZmxpY3Qgdmlld2VyIGNsYXNzLlxuICAgICAqIEByZXR1cm5zIHtWaWV3ZXJ9IFRoZSB2aWV3ZXIgY2xhc3MuXG4gICAgICovXG4gIH1dLCBbe1xuICAgIGtleTogXCJub0NvbmZsaWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgICB3aW5kb3cuVmlld2VyID0gQW5vdGhlclZpZXdlcjtcbiAgICAgIHJldHVybiBWaWV3ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBkZWZhdWx0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgbmV3IGRlZmF1bHQgb3B0aW9ucy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXREZWZhdWx0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREZWZhdWx0cyhvcHRpb25zKSB7XG4gICAgICBhc3NpZ24oREVGQVVMVFMsIGlzUGxhaW5PYmplY3Qob3B0aW9ucykgJiYgb3B0aW9ucyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBWaWV3ZXI7XG59KCk7XG5hc3NpZ24oVmlld2VyLnByb3RvdHlwZSwgcmVuZGVyLCBldmVudHMsIGhhbmRsZXJzLCBtZXRob2RzLCBvdGhlcnMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXdlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/viewerjs/dist/viewer.common.js\n");

/***/ })

};
;